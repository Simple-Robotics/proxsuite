<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>proxsuite: ProxQP API with examples</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/SVG"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeDarkModeToggle.init()
    </script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">proxsuite<span id="projectnumber">&#160;0.2.0</span>
   </div>
   <div id="projectbrief">The Advanced Proximal Optimization Toolbox</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_doc_2_PROXQP_API_2_ProxQP_api.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">ProxQP API with examples </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >ProxQP solves convex quadratic programs, which consists in minimizing a convex quadratic cost under some linear constraints. It is mathematically described as:</p>
<p >$$\begin{equation}\label{eq:QP}\tag{QP} \begin{aligned} \min_{x\in\mathbb{R}^{d}} &amp; \quad \frac{1}{2}x^{T}Hx+g^{T}x \\ \text{s.t.}&amp;\left\{ \begin{array}{ll} Ax = b, \\ Cx \leq u. \\ \end{array} \right. \end{aligned} \end{equation}\\ \text{with } H\in\mathbb{R}^{d\times d}, A\in\mathbb{R}^{n_\text{eq}\times d}, C\in\mathbb{R}^{n_\text{in}\times d}, b\in\mathbb{R}^{n_\text{eq}}, u\in\mathbb{R}^{n_\text{in}}. $$ H is a real symmetric positive semi-definite matrix. d is the problem dimension (i.e., the number of primal variables), while n_eq and n_in are the numbers of equality and inequality constraints respectively.</p>
<p >For linearly constrained convex optimization problems such as \eqref{eq:QP}, strong duality holds and the associated KKT conditions are necessary and sufficient for ensuring a primal-dual point (x,y,z) to be optimal (see, e.g.,<a href="https://web.stanford.edu/~boyd/cvxbook/">Section 5.2.3</a>} and <a href="https://web.stanford.edu/~boyd/papers/pdf/osqp.pdf">Section 2, page 5</a> for more details). For \eqref{eq:QP}, the KKT system is given by the set of equations:</p>
<p >$$\begin{equation}\label{qp:kkt}\tag{KKT} \begin{aligned} &amp;\left\{ \begin{array}{ll} Hx+g+A^Ty+C^Tz = 0, \\ Ax-b = 0, \\ Cx \leq u, \\ z\odot[Cx-u] = 0,\\ \end{array} \right. \end{aligned} \end{equation}$$</p>
<p >where the last equation involves the Hadamard product (i.e., for two vectors u and v, the Hadamard product is the vector whose ith entry is u_i v_i).</p>
<p >In practice, we look for a triplet (x,y,z) satisfying these optimality conditions \eqref{qp:kkt} up to a certain level of absolute accuracy (dependent of the application), leading us to the following natural absolute stopping criterion:</p>
<p >$$\begin{equation}\label{eq:approx_qp_sol} \begin{aligned} &amp;\left\{ \begin{array}{ll} |Hx+g+A^Ty+C^Tz|_{\infty} \leq \epsilon_{abs}, \\ |Ax-b|_{\infty} \leq \epsilon_{abs}, \\ |[Cx-u]_+|_{\infty}\leq \epsilon_{abs}. \\ \end{array} \right. \end{aligned} \end{equation}$$</p>
<p >The infite norm is preferred to the L2 norm as it is independent of the problem dimensions. It is also common to consider relative convergence criteria for early-stopping, as absolute targets might not bet reached due to numerical issues. ProxQP provides it in a similar way as OSQP (for more details see, e.g., <a href="https://web.stanford.edu/~boyd/papers/pdf/osqp.pdf">section 3.4</a>). Hence more generally the following stopping criterion can be used.</p>
<p >$$\begin{equation}\label{eq:approx_qp_sol_relative_criterion} \begin{aligned} &amp;\left\{ \begin{array}{ll} |Hx+g+A^Ty+C^Tz|_{\infty} \leq \epsilon_{\text{abs}} + \epsilon_{\text{rel}}\max(|Hx|_{\infty},|A^Ty|_{\infty},|C^Tz|_{\infty},|g|_{\infty}), \\ |Ax-b|_{\infty} \leq \epsilon_{\text{abs}} +\epsilon_{\text{rel}}\max(|Ax|_{\infty},|b|_{\infty}), \\ |[Cx-u]_+|_{\infty}\leq \epsilon_{\text{abs}} +\epsilon_{\text{rel}}\max(|Cx|_{\infty},|u|_{\infty}). \\ \end{array} \right. \end{aligned} \end{equation}$$</p>
<h1><a class="anchor" id="OverviewAPIstructure"></a>
ProxQP unified API for dense and sparse backends</h1>
<p >ProxQP algorithm is implemented in two versions specialized for dense and sparse matrices. One simple and unified API has been designed for loading the dense and sparse backends. Concretely, it contains three methods:</p><ul>
<li>init : for initializing the QP model, along with some parameters,</li>
<li>solve : for solving the QP problem,</li>
<li>update : for updating some parameters of the QP model.</li>
</ul>
<p >In what follows, we will make several examples for illustrating how to use this API in C++ and python. Some subttle differences exist nevertheless between the dense and sparse backends, and we will point them out when needed. We will also present all solver's possible settings and show where are stored the results. We will then give some recommandations about which backend to use considering your needs.</p>
<h2><a class="anchor" id="OverviewAPI"></a>
The API structure</h2>
<p >When creating a Qp object in C++ or python, it contains automatically the following sub-classes:</p><ul>
<li>model: a class storing the QP problem model which we want to solve,</li>
<li>results: a class storing the main solver's results,</li>
<li>settings: a class with all solver's settings,</li>
<li>work: a class (not exposed in python), with auxiliary variables used by the solver for its subroutines.</li>
</ul>
<p >For loading ProxQP with dense backend it is as simple as the following code below:</p>
<table class="manual">
<tr>
<th>examples/cpp/loading_dense_qp.cpp </th><th>examples/python/loading_dense_qp.py  </th></tr>
<tr>
<td valign="top"><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="dense_8hpp.html">proxsuite/proxqp/dense/dense.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceproxsuite_1_1proxqp.html">proxsuite::proxqp</a>;</div>
<div class="line"><span class="keyword">using </span>T = double;</div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main()</div>
<div class="line">{</div>
<div class="line">  dense::isize dim = 10;</div>
<div class="line">  dense::isize n_eq(dim / 4);</div>
<div class="line">  dense::isize n_in(dim / 4);</div>
<div class="line">  <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1dense_1_1QP.html">dense::QP&lt;T&gt;</a> qp(dim, n_eq, n_in);</div>
<div class="line">}</div>
<div class="ttc" id="adense_8hpp_html"><div class="ttname"><a href="dense_8hpp.html">dense.hpp</a></div></div>
<div class="ttc" id="anamespaceproxsuite_1_1proxqp_html"><div class="ttname"><a href="namespaceproxsuite_1_1proxqp.html">proxsuite::proxqp</a></div><div class="ttdef"><b>Definition:</b> <a href="dense_2fwd_8hpp_source.html#l00011">fwd.hpp:11</a></div></div>
<div class="ttc" id="astructproxsuite_1_1proxqp_1_1dense_1_1QP_html"><div class="ttname"><a href="structproxsuite_1_1proxqp_1_1dense_1_1QP.html">proxsuite::proxqp::dense::QP</a></div><div class="ttdoc">This class defines the API of PROXQP solver with dense backend.</div><div class="ttdef"><b>Definition:</b> <a href="dense_2wrapper_8hpp_source.html#l00081">wrapper.hpp:82</a></div></div>
</div><!-- fragment -->  </td><td valign="top"><div class="fragment"><div class="line"><span class="keyword">import</span> proxsuite</div>
<div class="line"> </div>
<div class="line">n = 10</div>
<div class="line">n_eq = 2</div>
<div class="line">n_in = 2</div>
<div class="line">qp = <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1dense_1_1QP.html">proxsuite.proxqp.dense.QP</a>(n, n_eq, n_in)</div>
</div><!-- fragment -->   </td></tr>
</table>
<p >The dimensions of the problem (i.e., n is the dimension of primal variable x, n_eq the number of equality constraints, and n_in the number of inequality constraints) are used for allocating the space needed for the Qp object. The dense Qp object is templated by the floatting precision of the QP model (in the example above in C++ a double precision). Note that for model to be valid, the primal dimension (i.e., n) must be strictly positive. If it is not the case an assertion will be raised precising this issue.</p>
<p >For loading ProxQP with sparse backend they are two possibilities:</p><ul>
<li>one can use as before the dimensions of the QP problem (i.e., n, n_eq and n_in)</li>
<li>or one can use the sparsity structure of the matrices defining the QP problem. More precisely, if H designs the quadratic cost of the model, A the equality constraint matrix, and C the inequality constraint matrix, one can pass in entry a boolean mask of these matrices (i.e., matrices with true value when one entry is non zero) for initializing the Qp object.</li>
</ul>
<table class="manual">
<tr>
<th>examples/cpp/loading_sparse_qp.cpp </th><th>examples/python/loading_sparse_qp.py  </th></tr>
<tr>
<td valign="top"><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse_8hpp.html">proxsuite/proxqp/sparse/sparse.hpp</a>&gt;</span> <span class="comment">// get the sparse API of ProxQP</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="random__qp__problems_8hpp.html">proxsuite/proxqp/utils/random_qp_problems.hpp</a>&gt;</span> <span class="comment">// used for generating a random convex qp</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceproxsuite_1_1proxqp.html">proxsuite::proxqp</a>;</div>
<div class="line"><span class="keyword">using </span>T = double;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main()</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// design a qp object using QP problem dimensions</span></div>
<div class="line">  isize n = 10;</div>
<div class="line">  isize n_eq(n / 4);</div>
<div class="line">  isize n_in(n / 4);</div>
<div class="line">  <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1sparse_1_1QP.html">sparse::QP&lt;T, isize&gt;</a> qp(n, n_eq, n_in);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// assume you generate these matrices H, A and C for your QP problem</span></div>
<div class="line"> </div>
<div class="line">  T p = 0.15;            <span class="comment">// level of sparsity</span></div>
<div class="line">  T conditioning = 10.0; <span class="comment">// conditioning level for H</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> H = <a class="code hl_function" href="namespaceproxsuite_1_1proxqp_1_1utils_1_1rand.html#a51eb1a46428d5c6a4ba8c97816eb3248">::proxsuite::proxqp::utils::rand::sparse_positive_definite_rand</a>(</div>
<div class="line">    n, conditioning, p);</div>
<div class="line">  <span class="keyword">auto</span> A = ::proxsuite::proxqp::utils::rand::sparse_matrix_rand&lt;T&gt;(n_eq, n, p);</div>
<div class="line">  <span class="keyword">auto</span> C = ::proxsuite::proxqp::utils::rand::sparse_matrix_rand&lt;T&gt;(n_in, n, p);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// design a qp2 object using sparsity masks of H, A and C</span></div>
<div class="line">  <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1sparse_1_1QP.html">proxsuite::proxqp::sparse::QP&lt;T, isize&gt;</a> qp2(</div>
<div class="line">    H.cast&lt;<span class="keywordtype">bool</span>&gt;(), A.cast&lt;<span class="keywordtype">bool</span>&gt;(), C.cast&lt;<span class="keywordtype">bool</span>&gt;());</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceproxsuite_1_1proxqp_1_1utils_1_1rand_html_a51eb1a46428d5c6a4ba8c97816eb3248"><div class="ttname"><a href="namespaceproxsuite_1_1proxqp_1_1utils_1_1rand.html#a51eb1a46428d5c6a4ba8c97816eb3248">proxsuite::proxqp::utils::rand::sparse_positive_definite_rand</a></div><div class="ttdeci">auto sparse_positive_definite_rand(isize n, Scalar cond, Scalar p) -&gt; SparseMat&lt; Scalar &gt;</div><div class="ttdef"><b>Definition:</b> <a href="random__qp__problems_8hpp_source.html#l00192">random_qp_problems.hpp:192</a></div></div>
<div class="ttc" id="arandom__qp__problems_8hpp_html"><div class="ttname"><a href="random__qp__problems_8hpp.html">random_qp_problems.hpp</a></div></div>
<div class="ttc" id="asparse_8hpp_html"><div class="ttname"><a href="sparse_8hpp.html">sparse.hpp</a></div></div>
<div class="ttc" id="astructproxsuite_1_1proxqp_1_1sparse_1_1QP_html"><div class="ttname"><a href="structproxsuite_1_1proxqp_1_1sparse_1_1QP.html">proxsuite::proxqp::sparse::QP</a></div><div class="ttdoc">This class defines the API of PROXQP solver with sparse backend.</div><div class="ttdef"><b>Definition:</b> <a href="sparse_2wrapper_8hpp_source.html#l00090">wrapper.hpp:91</a></div></div>
</div><!-- fragment -->  </td><td valign="top"><div class="fragment"><div class="line"><span class="keyword">import</span> proxsuite</div>
<div class="line"> </div>
<div class="line"><span class="comment"># load a qp object using qp problem dimensions</span></div>
<div class="line">n = 10</div>
<div class="line">n_eq = 2</div>
<div class="line">n_in = 2</div>
<div class="line">qp = <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1sparse_1_1QP.html">proxsuite.proxqp.sparse.QP</a>(n, n_eq, n_in)</div>
<div class="line"> </div>
<div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"><span class="keyword">import</span> scipy.sparse <span class="keyword">as</span> spa</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>generate_mixed_qp(n, seed=1):</div>
<div class="line">    <span class="comment"># A function for generating random convex qps</span></div>
<div class="line"> </div>
<div class="line">    np.random.seed(seed)</div>
<div class="line">    n_eq = int(n / 4)</div>
<div class="line">    n_in = int(n / 4)</div>
<div class="line">    m = n_eq + n_in</div>
<div class="line"> </div>
<div class="line">    P = spa.random(</div>
<div class="line">        n, n, density=0.075, data_rvs=np.random.randn, format=<span class="stringliteral">&quot;csc&quot;</span></div>
<div class="line">    ).toarray()</div>
<div class="line">    P = (P + P.T) / 2.0</div>
<div class="line"> </div>
<div class="line">    s = max(np.absolute(np.linalg.eigvals(P)))</div>
<div class="line">    P += (abs(s) + 1e-02) * spa.eye(n)</div>
<div class="line">    P = spa.coo_matrix(P)</div>
<div class="line">    q = np.random.randn(n)</div>
<div class="line">    A = spa.random(m, n, density=0.15, data_rvs=np.random.randn, format=<span class="stringliteral">&quot;csc&quot;</span>)</div>
<div class="line">    v = np.random.randn(n)  <span class="comment"># Fictitious solution</span></div>
<div class="line">    delta = np.random.rand(m)  <span class="comment"># To get inequality</span></div>
<div class="line">    u = A @ v</div>
<div class="line">    l = -1.0e20 * np.ones(m)</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> P, q, A[:n_eq, :], u[:n_eq], A[n_in:, :], u[n_in:], l[n_in:]</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment"># load a qp2 object using matrix masks</span></div>
<div class="line">H, g, A, b, C, u, l = generate_mixed_qp(n)</div>
<div class="line"> </div>
<div class="line">H_ = H != 0.0</div>
<div class="line">A_ = A != 0.0</div>
<div class="line">C_ = C != 0.0</div>
<div class="line">qp2 = <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1sparse_1_1QP.html">proxsuite.proxqp.sparse.QP</a>(H_, A_, C_)</div>
</div><!-- fragment -->   </td></tr>
</table>
<p >The sparse Qp object is templated by the floatting precision of the QP model (in the example above a double precision), and the integer precision used for the different types of non zero indices used (for the associated sparse matrix representation used).</p>
<h2><a class="anchor" id="explanationInitMethod"></a>
The init method</h2>
<p >Once you have defined a Qp object, the init method enables you setting up the QP problem to be solved (the example is given for the dense backend, it is similar for sparse backend).</p>
<table class="manual">
<tr>
<th>examples/cpp/init_dense_qp.cpp </th><th>examples/python/init_dense_qp.py  </th></tr>
<tr>
<td valign="top"><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dense_8hpp.html">proxsuite/proxqp/dense/dense.hpp</a>&gt;</span> <span class="comment">// load the dense solver backend</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="random__qp__problems_8hpp.html">proxsuite/proxqp/utils/random_qp_problems.hpp</a>&gt;</span> <span class="comment">// used for generating a random convex qp</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceproxsuite_1_1proxqp.html">proxsuite::proxqp</a>;</div>
<div class="line"><span class="keyword">using </span>T = double;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main()</div>
<div class="line">{</div>
<div class="line">  isize dim = 10;</div>
<div class="line">  isize n_eq(dim / 4);</div>
<div class="line">  isize n_in(dim / 4);</div>
<div class="line">  <span class="comment">// generate a random qp</span></div>
<div class="line">  T sparsity_factor(0.15);</div>
<div class="line">  T strong_convexity_factor(1.e-2);</div>
<div class="line">  <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html">dense::Model&lt;T&gt;</a> qp_random = utils::dense_strongly_convex_qp(</div>
<div class="line">    dim, n_eq, n_in, sparsity_factor, strong_convexity_factor);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1dense_1_1QP.html">dense::QP&lt;T&gt;</a> qp(dim, n_eq, n_in); <span class="comment">// create the QP object</span></div>
<div class="line">  qp.init(qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a420a3bc7af86f6eaf6584f3f6b163e39">H</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#aab44afb08fed7665a9a1b6b76123bc2e">g</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a2faa69ae13a95d134f8f55e50935486b">A</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a35143abc2bf2a3dc4d4d0030376f00d7">b</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#ab9585ea151d2a15be6a672b2204f67a9">C</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a1e83a4aff28b7e6f81ecb962afaa6166">l</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#ab44246d2c5fd3b5bf19e1cfd6e556456">u</a>); <span class="comment">// initialize the model</span></div>
<div class="line">}</div>
<div class="ttc" id="astructproxsuite_1_1proxqp_1_1dense_1_1Model_html"><div class="ttname"><a href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html">proxsuite::proxqp::dense::Model</a></div><div class="ttdoc">This class stores the model of the QP problem.</div><div class="ttdef"><b>Definition:</b> <a href="dense_2model_8hpp_source.html#l00023">model.hpp:24</a></div></div>
<div class="ttc" id="astructproxsuite_1_1proxqp_1_1dense_1_1Model_html_a1e83a4aff28b7e6f81ecb962afaa6166"><div class="ttname"><a href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a1e83a4aff28b7e6f81ecb962afaa6166">proxsuite::proxqp::dense::Model::l</a></div><div class="ttdeci">Vec&lt; T &gt; l</div><div class="ttdef"><b>Definition:</b> <a href="dense_2model_8hpp_source.html#l00033">model.hpp:33</a></div></div>
<div class="ttc" id="astructproxsuite_1_1proxqp_1_1dense_1_1Model_html_a2faa69ae13a95d134f8f55e50935486b"><div class="ttname"><a href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a2faa69ae13a95d134f8f55e50935486b">proxsuite::proxqp::dense::Model::A</a></div><div class="ttdeci">Mat&lt; T &gt; A</div><div class="ttdef"><b>Definition:</b> <a href="dense_2model_8hpp_source.html#l00029">model.hpp:29</a></div></div>
<div class="ttc" id="astructproxsuite_1_1proxqp_1_1dense_1_1Model_html_a35143abc2bf2a3dc4d4d0030376f00d7"><div class="ttname"><a href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a35143abc2bf2a3dc4d4d0030376f00d7">proxsuite::proxqp::dense::Model::b</a></div><div class="ttdeci">Vec&lt; T &gt; b</div><div class="ttdef"><b>Definition:</b> <a href="dense_2model_8hpp_source.html#l00031">model.hpp:31</a></div></div>
<div class="ttc" id="astructproxsuite_1_1proxqp_1_1dense_1_1Model_html_a420a3bc7af86f6eaf6584f3f6b163e39"><div class="ttname"><a href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a420a3bc7af86f6eaf6584f3f6b163e39">proxsuite::proxqp::dense::Model::H</a></div><div class="ttdeci">Mat&lt; T &gt; H</div><div class="ttdef"><b>Definition:</b> <a href="dense_2model_8hpp_source.html#l00027">model.hpp:27</a></div></div>
<div class="ttc" id="astructproxsuite_1_1proxqp_1_1dense_1_1Model_html_aab44afb08fed7665a9a1b6b76123bc2e"><div class="ttname"><a href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#aab44afb08fed7665a9a1b6b76123bc2e">proxsuite::proxqp::dense::Model::g</a></div><div class="ttdeci">Vec&lt; T &gt; g</div><div class="ttdef"><b>Definition:</b> <a href="dense_2model_8hpp_source.html#l00028">model.hpp:28</a></div></div>
<div class="ttc" id="astructproxsuite_1_1proxqp_1_1dense_1_1Model_html_ab44246d2c5fd3b5bf19e1cfd6e556456"><div class="ttname"><a href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#ab44246d2c5fd3b5bf19e1cfd6e556456">proxsuite::proxqp::dense::Model::u</a></div><div class="ttdeci">Vec&lt; T &gt; u</div><div class="ttdef"><b>Definition:</b> <a href="dense_2model_8hpp_source.html#l00032">model.hpp:32</a></div></div>
<div class="ttc" id="astructproxsuite_1_1proxqp_1_1dense_1_1Model_html_ab9585ea151d2a15be6a672b2204f67a9"><div class="ttname"><a href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#ab9585ea151d2a15be6a672b2204f67a9">proxsuite::proxqp::dense::Model::C</a></div><div class="ttdeci">Mat&lt; T &gt; C</div><div class="ttdef"><b>Definition:</b> <a href="dense_2model_8hpp_source.html#l00030">model.hpp:30</a></div></div>
</div><!-- fragment -->  </td><td valign="top"><div class="fragment"><div class="line"><span class="keyword">import</span> proxsuite</div>
<div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"><span class="keyword">import</span> scipy.sparse <span class="keyword">as</span> spa</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>generate_mixed_qp(n, seed=1):</div>
<div class="line">    <span class="comment"># A function for generating random convex qps</span></div>
<div class="line"> </div>
<div class="line">    np.random.seed(seed)</div>
<div class="line">    n_eq = int(n / 4)</div>
<div class="line">    n_in = int(n / 4)</div>
<div class="line">    m = n_eq + n_in</div>
<div class="line"> </div>
<div class="line">    P = spa.random(</div>
<div class="line">        n, n, density=0.075, data_rvs=np.random.randn, format=<span class="stringliteral">&quot;csc&quot;</span></div>
<div class="line">    ).toarray()</div>
<div class="line">    P = (P + P.T) / 2.0</div>
<div class="line"> </div>
<div class="line">    s = max(np.absolute(np.linalg.eigvals(P)))</div>
<div class="line">    P += (abs(s) + 1e-02) * spa.eye(n)</div>
<div class="line">    P = spa.coo_matrix(P)</div>
<div class="line">    q = np.random.randn(n)</div>
<div class="line">    A = spa.random(m, n, density=0.15, data_rvs=np.random.randn, format=<span class="stringliteral">&quot;csc&quot;</span>).toarray()</div>
<div class="line">    v = np.random.randn(n)  <span class="comment"># Fictitious solution</span></div>
<div class="line">    delta = np.random.rand(m)  <span class="comment"># To get inequality</span></div>
<div class="line">    u = A @ v</div>
<div class="line">    l = -1.0e20 * np.ones(m)</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> P.toarray(), q, A[:n_eq, :], u[:n_eq], A[n_in:, :], u[n_in:], l[n_in:]</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment"># load a qp object using qp problem dimensions</span></div>
<div class="line">n = 10</div>
<div class="line">n_eq = 2</div>
<div class="line">n_in = 2</div>
<div class="line">qp = <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1dense_1_1QP.html">proxsuite.proxqp.dense.QP</a>(n, n_eq, n_in)</div>
<div class="line"><span class="comment"># generate a random QP</span></div>
<div class="line">H, g, A, b, C, u, l = generate_mixed_qp(n)</div>
<div class="line"><span class="comment"># initialize the model of the problem to solve</span></div>
<div class="line">qp.init(H, g, A, b, C, l, u)</div>
</div><!-- fragment -->   </td></tr>
</table>
<p >Note that with its dense backend, ProxQP solver manipulates matrices in dense representations (in the same spirit, the solver with sparse backend manipulates entries in sparse format). In the example above the matrices are originally in sparse format, and eventually converted into dense format. Note that if some elements of your QP model are not defined (for example a QP without linear cost or inequality constraints), you can either pass a None argument, or a matrix with zero shape for specifying it. We provide an example below in cpp and python (for the dense case, it is similar with sparse backend).</p>
<table class="manual">
<tr>
<th>examples/cpp/initializing_with_none.cpp </th><th>examples/python/initializing_with_none.py  </th></tr>
<tr>
<td valign="top"><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="dense_8hpp.html">proxsuite/proxqp/dense/dense.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="random__qp__problems_8hpp.html">proxsuite/proxqp/utils/random_qp_problems.hpp</a>&gt;</span> <span class="comment">// used for generating a random convex qp</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceproxsuite_1_1proxqp.html">proxsuite::proxqp</a>;</div>
<div class="line"><span class="keyword">using </span>T = double;</div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main()</div>
<div class="line">{</div>
<div class="line">  dense::isize dim = 10;</div>
<div class="line">  dense::isize n_eq(0);</div>
<div class="line">  dense::isize n_in(0);</div>
<div class="line">  <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1dense_1_1QP.html">dense::QP&lt;T&gt;</a> qp(dim, n_eq, n_in);</div>
<div class="line">  T strong_convexity_factor(0.1);</div>
<div class="line">  T sparsity_factor(0.15);</div>
<div class="line">  <span class="comment">// we generate a qp, so the function used from helpers.hpp is</span></div>
<div class="line">  <span class="comment">// in proxqp namespace. The qp is in dense eigen format and</span></div>
<div class="line">  <span class="comment">// you can control its sparsity ratio and strong convexity factor.</span></div>
<div class="line">  <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html">dense::Model&lt;T&gt;</a> qp_random = utils::dense_strongly_convex_qp(</div>
<div class="line">    dim, n_eq, n_in, sparsity_factor, strong_convexity_factor);</div>
<div class="line"> </div>
<div class="line">  qp.init(qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a420a3bc7af86f6eaf6584f3f6b163e39">H</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#aab44afb08fed7665a9a1b6b76123bc2e">g</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a2faa69ae13a95d134f8f55e50935486b">A</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a35143abc2bf2a3dc4d4d0030376f00d7">b</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#ab9585ea151d2a15be6a672b2204f67a9">C</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a1e83a4aff28b7e6f81ecb962afaa6166">l</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#ab44246d2c5fd3b5bf19e1cfd6e556456">u</a>); <span class="comment">// initialization with zero shape matrices</span></div>
<div class="line">  <span class="comment">// it is equivalent to do qp.init(qp_random.H, qp_random.g,</span></div>
<div class="line">  <span class="comment">// std::nullopt,std::nullopt,std::nullopt,std::nullopt,std::nullopt);</span></div>
<div class="line">  qp.solve();</div>
<div class="line">  <span class="comment">// print an optimal solution x,y and z</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal x: &quot;</span> &lt;&lt; qp.results.x &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal y: &quot;</span> &lt;&lt; qp.results.y &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal z: &quot;</span> &lt;&lt; qp.results.z &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment -->  </td><td valign="top"><div class="fragment"><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"><span class="keyword">import</span> proxsuite</div>
<div class="line"> </div>
<div class="line">H = np.array([[65.0, -22.0, -16.0], [-22.0, 14.0, 7.0], [-16.0, 7.0, 5.0]])</div>
<div class="line">g = np.array([-13.0, 15.0, 7.0])</div>
<div class="line">A = <span class="keywordtype">None</span></div>
<div class="line">b = <span class="keywordtype">None</span></div>
<div class="line">C = <span class="keywordtype">None</span></div>
<div class="line">u = <span class="keywordtype">None</span></div>
<div class="line">l = <span class="keywordtype">None</span></div>
<div class="line"> </div>
<div class="line">qp = <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1dense_1_1QP.html">proxsuite.proxqp.dense.QP</a>(3, 0, 0)</div>
<div class="line">qp.init(H, g, A, b, C, l, u)  <span class="comment"># it is equivalent to do as well qp.init(H, g)</span></div>
<div class="line">qp.solve()</div>
<div class="line">print(<span class="stringliteral">&quot;optimal x: {}&quot;</span>.format(qp.results.x))</div>
</div><!-- fragment -->   </td></tr>
</table>
<p >With the init method, you can also setting-up on the same time some other parameters in the following order:</p><ul>
<li>compute_preconditioner: a boolean parameter for executing or not the preconditioner. The preconditioner is an algorithm used (for the moment we use <a href="https://cds.cern.ch/record/585592/files/CM-P00040415.pdf">Ruiz equilibrator</a>) for reducing the ill-conditioning of the QP problem, and hence speeding-up the solver and increasing its accuracy. It consists mostly of an heuristic involving linear scalings. Note that for very ill-conditioned QP problem, when one asks for a very accurate solution, the unscaling procedure can become less precise (we provide some remarks about this subject in section 6.D of the <a href="https://hal.inria.fr/hal-03683733/file/Yet_another_QP_solver_for_robotics_and_beyond.pdf">following paper</a>). By default its value is set to true.</li>
<li>rho: the proximal step size wrt primal variable. Reducing its value speed-ups convergence wrt primal variable (but increases as well ill-conditioning of sub-problems to solve). The minimal value it can take is 1.e-7. By default its value is set to 1.e-6.</li>
<li>mu_eq: the proximal step size wrt equality constrained multiplier. Reducing its value speed-ups convergence wrt equality constrained variable (but increases as well ill-conditioning of sub-problems to solve). The minimal value it can take is 1.e-9. By default its value is set to 1.e-3.</li>
<li>mu_in: the proximal step size wrt inequality constrained multiplier. Reducing its value speed-ups convergence wrt inequality constrained variable (but increases as well ill-conditioning of sub-problems to solve). The minimal value it can take is 1.e-9. By default its value is set to 1.e-1.</li>
</ul>
<p >We provide below one example in C++ and python.</p>
<table class="manual">
<tr>
<th>examples/cpp/init_dense_qp_with_other_options.cpp </th><th>examples/python/init_dense_qp_with_other_options.py  </th></tr>
<tr>
<td valign="top"><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dense_8hpp.html">proxsuite/proxqp/dense/dense.hpp</a>&gt;</span> <span class="comment">// load the dense solver backend</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="random__qp__problems_8hpp.html">proxsuite/proxqp/utils/random_qp_problems.hpp</a>&gt;</span> <span class="comment">// used for generating a random convex qp</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceproxsuite_1_1proxqp.html">proxsuite::proxqp</a>;</div>
<div class="line"><span class="keyword">using </span>T = double;</div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main()</div>
<div class="line">{</div>
<div class="line">  isize dim = 10;</div>
<div class="line">  isize n_eq(dim / 4);</div>
<div class="line">  isize n_in(dim / 4);</div>
<div class="line">  <span class="comment">// generate a random qp</span></div>
<div class="line">  T sparsity_factor(0.15);</div>
<div class="line">  T strong_convexity_factor(1.e-2);</div>
<div class="line">  <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html">dense::Model&lt;T&gt;</a> qp_random = utils::dense_strongly_convex_qp(</div>
<div class="line">    dim, n_eq, n_in, sparsity_factor, strong_convexity_factor);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1dense_1_1QP.html">dense::QP&lt;T&gt;</a> qp(</div>
<div class="line">    dim, n_eq, n_in); <span class="comment">// create the QP</span></div>
<div class="line">                      <span class="comment">// initialize the model, along with another rho parameter</span></div>
<div class="line">  qp.init(qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a420a3bc7af86f6eaf6584f3f6b163e39">H</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#aab44afb08fed7665a9a1b6b76123bc2e">g</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a2faa69ae13a95d134f8f55e50935486b">A</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a35143abc2bf2a3dc4d4d0030376f00d7">b</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#ab9585ea151d2a15be6a672b2204f67a9">C</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a1e83a4aff28b7e6f81ecb962afaa6166">l</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#ab44246d2c5fd3b5bf19e1cfd6e556456">u</a>,</div>
<div class="line">          <span class="keyword">true</span>,</div>
<div class="line">          <span class="comment">/*rho*/</span> 1.e-7);</div>
<div class="line">  <span class="comment">// in c++ you must follow the order speficied in the API for the parameters</span></div>
<div class="line">  <span class="comment">// if you don&#39;t want to change one parameter (here compute_preconditioner),</span></div>
<div class="line">  <span class="comment">// just let it be std::nullopt</span></div>
<div class="line">}</div>
</div><!-- fragment -->  </td><td valign="top"><div class="fragment"><div class="line"><span class="keyword">import</span> proxsuite</div>
<div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"><span class="keyword">import</span> scipy.sparse <span class="keyword">as</span> spa</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>generate_mixed_qp(n, seed=1):</div>
<div class="line">    <span class="comment"># A function for generating random convex qps</span></div>
<div class="line"> </div>
<div class="line">    np.random.seed(seed)</div>
<div class="line">    n_eq = int(n / 4)</div>
<div class="line">    n_in = int(n / 4)</div>
<div class="line">    m = n_eq + n_in</div>
<div class="line"> </div>
<div class="line">    P = spa.random(</div>
<div class="line">        n, n, density=0.075, data_rvs=np.random.randn, format=<span class="stringliteral">&quot;csc&quot;</span></div>
<div class="line">    ).toarray()</div>
<div class="line">    P = (P + P.T) / 2.0</div>
<div class="line"> </div>
<div class="line">    s = max(np.absolute(np.linalg.eigvals(P)))</div>
<div class="line">    P += (abs(s) + 1e-02) * spa.eye(n)</div>
<div class="line">    P = spa.coo_matrix(P)</div>
<div class="line">    q = np.random.randn(n)</div>
<div class="line">    A = spa.random(m, n, density=0.15, data_rvs=np.random.randn, format=<span class="stringliteral">&quot;csc&quot;</span>).toarray()</div>
<div class="line">    v = np.random.randn(n)  <span class="comment"># Fictitious solution</span></div>
<div class="line">    delta = np.random.rand(m)  <span class="comment"># To get inequality</span></div>
<div class="line">    u = A @ v</div>
<div class="line">    l = -1.0e20 * np.ones(m)</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> P.toarray(), q, A[:n_eq, :], u[:n_eq], A[n_in:, :], u[n_in:], l[n_in:]</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment"># load a qp object using qp problem dimensions</span></div>
<div class="line">n = 10</div>
<div class="line">n_eq = 2</div>
<div class="line">n_in = 2</div>
<div class="line">qp = <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1dense_1_1QP.html">proxsuite.proxqp.dense.QP</a>(n, n_eq, n_in)</div>
<div class="line"><span class="comment"># generate a random QP</span></div>
<div class="line">H, g, A, b, C, u, l = generate_mixed_qp(n)</div>
<div class="line"><span class="comment"># initialize the model of the problem to solve with another rho parameter</span></div>
<div class="line">qp.init(H, g, A, b, C, l, u, rho=1.0e-7)</div>
</div><!-- fragment -->   </td></tr>
</table>
<p >Furthermore, some settings must be defined before the init method to take effect. For example, if you want the solver to compute the runtime properly (the sum of the setup time and the solving time), you must set this option before the init method (which is part of the setup time). We provide below an example.</p>
<table class="manual">
<tr>
<th>examples/cpp/init_dense_qp_with_timings.cpp </th><th>examples/python/init_dense_qp_with_timings.py  </th></tr>
<tr>
<td valign="top"><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dense_8hpp.html">proxsuite/proxqp/dense/dense.hpp</a>&gt;</span> <span class="comment">// load the dense solver backend</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="random__qp__problems_8hpp.html">proxsuite/proxqp/utils/random_qp_problems.hpp</a>&gt;</span> <span class="comment">// used for generating a random convex qp</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceproxsuite_1_1proxqp.html">proxsuite::proxqp</a>;</div>
<div class="line"><span class="keyword">using </span>T = double;</div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main()</div>
<div class="line">{</div>
<div class="line">  isize dim = 10;</div>
<div class="line">  isize n_eq(dim / 4);</div>
<div class="line">  isize n_in(dim / 4);</div>
<div class="line">  <span class="comment">// generate a random qp</span></div>
<div class="line">  T sparsity_factor(0.15);</div>
<div class="line">  T strong_convexity_factor(1.e-2);</div>
<div class="line">  <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html">dense::Model&lt;T&gt;</a> qp_random = utils::dense_strongly_convex_qp(</div>
<div class="line">    dim, n_eq, n_in, sparsity_factor, strong_convexity_factor);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1dense_1_1QP.html">dense::QP&lt;T&gt;</a> qp(dim, n_eq, n_in);   <span class="comment">// create the QP object</span></div>
<div class="line">  qp.settings.compute_timings = <span class="keyword">true</span>; <span class="comment">// compute all timings</span></div>
<div class="line">  qp.init(qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a420a3bc7af86f6eaf6584f3f6b163e39">H</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#aab44afb08fed7665a9a1b6b76123bc2e">g</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a2faa69ae13a95d134f8f55e50935486b">A</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a35143abc2bf2a3dc4d4d0030376f00d7">b</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#ab9585ea151d2a15be6a672b2204f67a9">C</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a1e83a4aff28b7e6f81ecb962afaa6166">l</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#ab44246d2c5fd3b5bf19e1cfd6e556456">u</a>); <span class="comment">// initialize the model</span></div>
<div class="line">}</div>
</div><!-- fragment -->  </td><td valign="top"><div class="fragment"><div class="line"><span class="keyword">import</span> proxsuite</div>
<div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"><span class="keyword">import</span> scipy.sparse <span class="keyword">as</span> spa</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>generate_mixed_qp(n, seed=1):</div>
<div class="line">    <span class="comment"># A function for generating random convex qps</span></div>
<div class="line"> </div>
<div class="line">    np.random.seed(seed)</div>
<div class="line">    n_eq = int(n / 4)</div>
<div class="line">    n_in = int(n / 4)</div>
<div class="line">    m = n_eq + n_in</div>
<div class="line"> </div>
<div class="line">    P = spa.random(</div>
<div class="line">        n, n, density=0.075, data_rvs=np.random.randn, format=<span class="stringliteral">&quot;csc&quot;</span></div>
<div class="line">    ).toarray()</div>
<div class="line">    P = (P + P.T) / 2.0</div>
<div class="line"> </div>
<div class="line">    s = max(np.absolute(np.linalg.eigvals(P)))</div>
<div class="line">    P += (abs(s) + 1e-02) * spa.eye(n)</div>
<div class="line">    P = spa.coo_matrix(P)</div>
<div class="line">    q = np.random.randn(n)</div>
<div class="line">    A = spa.random(m, n, density=0.15, data_rvs=np.random.randn, format=<span class="stringliteral">&quot;csc&quot;</span>).toarray()</div>
<div class="line">    v = np.random.randn(n)  <span class="comment"># Fictitious solution</span></div>
<div class="line">    delta = np.random.rand(m)  <span class="comment"># To get inequality</span></div>
<div class="line">    u = A @ v</div>
<div class="line">    l = -1.0e20 * np.ones(m)</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> P.toarray(), q, A[:n_eq, :], u[:n_eq], A[n_in:, :], u[n_in:], l[n_in:]</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment"># load a qp object using qp problem dimensions</span></div>
<div class="line">n = 10</div>
<div class="line">n_eq = 2</div>
<div class="line">n_in = 2</div>
<div class="line">qp = <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1dense_1_1QP.html">proxsuite.proxqp.dense.QP</a>(n, n_eq, n_in)</div>
<div class="line"><span class="comment"># generate a random QP</span></div>
<div class="line">H, g, A, b, C, u, l = generate_mixed_qp(n)</div>
<div class="line"><span class="comment"># initialize the model of the problem to solve</span></div>
<div class="line">qp.settings.compute_timings  <span class="comment"># compute all timings</span></div>
<div class="line">qp.init(H, g, A, b, C, l, u)</div>
</div><!-- fragment -->   </td></tr>
</table>
<h2><a class="anchor" id="explanationSolveMethod"></a>
The solve method</h2>
<p >Once you have defined a Qp object and initialized it with a model, the solve method enables you solving the QP problem. The method is overloaded with two modes considering whether you provide or not a warm start to the method. We give below two examples (for the dense backend, with the sparse one it is similar).</p>
<table class="manual">
<tr>
<th>examples/cpp/solve_dense_qp.cpp </th><th>examples/python/solve_dense_qp.py  </th></tr>
<tr>
<td valign="top"><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dense_8hpp.html">proxsuite/proxqp/dense/dense.hpp</a>&gt;</span> <span class="comment">// load the dense solver backend</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="random__qp__problems_8hpp.html">proxsuite/proxqp/utils/random_qp_problems.hpp</a>&gt;</span> <span class="comment">// used for generating a random convex qp</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceproxsuite_1_1proxqp.html">proxsuite::proxqp</a>;</div>
<div class="line"><span class="keyword">using </span>T = double;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main()</div>
<div class="line">{</div>
<div class="line">  isize dim = 10;</div>
<div class="line">  isize n_eq(dim / 4);</div>
<div class="line">  isize n_in(dim / 4);</div>
<div class="line">  <span class="comment">// generate a random qp</span></div>
<div class="line">  T sparsity_factor(0.15);</div>
<div class="line">  T strong_convexity_factor(1.e-2);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html">dense::Model&lt;T&gt;</a> qp_random = utils::dense_strongly_convex_qp(</div>
<div class="line">    dim, n_eq, n_in, sparsity_factor, strong_convexity_factor);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1dense_1_1QP.html">dense::QP&lt;T&gt;</a> qp(dim, n_eq, n_in); <span class="comment">// create the QP object</span></div>
<div class="line">  qp.init(qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a420a3bc7af86f6eaf6584f3f6b163e39">H</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#aab44afb08fed7665a9a1b6b76123bc2e">g</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a2faa69ae13a95d134f8f55e50935486b">A</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a35143abc2bf2a3dc4d4d0030376f00d7">b</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#ab9585ea151d2a15be6a672b2204f67a9">C</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a1e83a4aff28b7e6f81ecb962afaa6166">l</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#ab44246d2c5fd3b5bf19e1cfd6e556456">u</a>); <span class="comment">// initialize the model</span></div>
<div class="line">  qp.solve();           <span class="comment">// solve the problem without warm start</span></div>
<div class="line">  <span class="keyword">auto</span> x_wm = utils::rand::vector_rand&lt;T&gt;(dim);</div>
<div class="line">  <span class="keyword">auto</span> y_wm = utils::rand::vector_rand&lt;T&gt;(n_eq);</div>
<div class="line">  <span class="keyword">auto</span> z_wm = utils::rand::vector_rand&lt;T&gt;(n_in);</div>
<div class="line">  qp.solve(x_wm, y_wm,</div>
<div class="line">           z_wm); <span class="comment">// if you have a warm start, put it here</span></div>
<div class="line">  <span class="comment">// print an optimal solution x,y and z</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal x: &quot;</span> &lt;&lt; qp.results.x &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal y: &quot;</span> &lt;&lt; qp.results.y &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal z: &quot;</span> &lt;&lt; qp.results.z &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment -->  </td><td valign="top"><div class="fragment"><div class="line"><span class="keyword">import</span> proxsuite</div>
<div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"><span class="keyword">import</span> scipy.sparse <span class="keyword">as</span> spa</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>generate_mixed_qp(n, seed=1):</div>
<div class="line">    <span class="comment"># A function for generating sparse random convex qps in dense format</span></div>
<div class="line"> </div>
<div class="line">    np.random.seed(seed)</div>
<div class="line">    n_eq = int(n / 4)</div>
<div class="line">    n_in = int(n / 4)</div>
<div class="line">    m = n_eq + n_in</div>
<div class="line"> </div>
<div class="line">    P = spa.random(</div>
<div class="line">        n, n, density=0.075, data_rvs=np.random.randn, format=<span class="stringliteral">&quot;csc&quot;</span></div>
<div class="line">    ).toarray()</div>
<div class="line">    P = (P + P.T) / 2.0</div>
<div class="line"> </div>
<div class="line">    s = max(np.absolute(np.linalg.eigvals(P)))</div>
<div class="line">    P += (abs(s) + 1e-02) * spa.eye(n)</div>
<div class="line">    P = spa.coo_matrix(P)</div>
<div class="line">    q = np.random.randn(n)</div>
<div class="line">    A = spa.random(m, n, density=0.15, data_rvs=np.random.randn, format=<span class="stringliteral">&quot;csc&quot;</span>).toarray()</div>
<div class="line">    v = np.random.randn(n)  <span class="comment"># Fictitious solution</span></div>
<div class="line">    delta = np.random.rand(m)  <span class="comment"># To get inequality</span></div>
<div class="line">    u = A @ v</div>
<div class="line">    l = -1.0e20 * np.ones(m)</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> P.toarray(), q, A[:n_eq, :], u[:n_eq], A[n_in:, :], u[n_in:], l[n_in:]</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment"># load a qp object using qp problem dimensions</span></div>
<div class="line">n = 10</div>
<div class="line">n_eq = 2</div>
<div class="line">n_in = 2</div>
<div class="line">qp = <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1dense_1_1QP.html">proxsuite.proxqp.dense.QP</a>(n, n_eq, n_in)</div>
<div class="line"><span class="comment"># generate a random QP</span></div>
<div class="line">H, g, A, b, C, u, l = generate_mixed_qp(n)</div>
<div class="line"><span class="comment"># initialize the model of the problem to solve</span></div>
<div class="line">qp.init(H, g, A, b, C, l, u)</div>
<div class="line"><span class="comment"># solve without warm start</span></div>
<div class="line">qp.solve()</div>
<div class="line"><span class="comment"># solve with a warm start, for ex random one</span></div>
<div class="line">qp.solve(np.random.randn(n), np.random.randn(n_eq), np.random.randn(n_in))</div>
<div class="line"><span class="comment"># print an optimal solution</span></div>
<div class="line">print(<span class="stringliteral">&quot;optimal x: {}&quot;</span>.format(qp.results.x))</div>
<div class="line">print(<span class="stringliteral">&quot;optimal y: {}&quot;</span>.format(qp.results.y))</div>
<div class="line">print(<span class="stringliteral">&quot;optimal z: {}&quot;</span>.format(qp.results.z))</div>
</div><!-- fragment -->   </td></tr>
</table>
<p >Before ending this section, we will talk about how to activate some other settings before launching the solve method. To do so, you only need to define your desired settings (for example, the stopping criterion accuracy threshold eps_abs, or the verbose option) after initializing the Qp object. They will be then taken into account only if there are set before the solve method (otherwise, they will be taken into account when a next solve or update method is called). The full description of all the settings is provided at a dedicated section below. Here we just give an example to illustrate the mentioned notion above.</p>
<table class="manual">
<tr>
<th>examples/cpp/solve_dense_qp_with_setting.cpp </th><th>examples/python/solve_dense_qp_with_setting.py  </th></tr>
<tr>
<td valign="top"><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dense_8hpp.html">proxsuite/proxqp/dense/dense.hpp</a>&gt;</span> <span class="comment">// load the dense solver backend</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="random__qp__problems_8hpp.html">proxsuite/proxqp/utils/random_qp_problems.hpp</a>&gt;</span> <span class="comment">// used for generating a random convex qp</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceproxsuite_1_1proxqp.html">proxsuite::proxqp</a>;</div>
<div class="line"><span class="keyword">using </span>T = double;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main()</div>
<div class="line">{</div>
<div class="line">  dense::isize dim = 10;</div>
<div class="line">  dense::isize n_eq(dim / 4);</div>
<div class="line">  dense::isize n_in(dim / 4);</div>
<div class="line">  <span class="comment">// generate a random qp</span></div>
<div class="line">  T sparsity_factor(0.15);</div>
<div class="line">  T strong_convexity_factor(1.e-2);</div>
<div class="line">  <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html">dense::Model&lt;T&gt;</a> qp_random = utils::dense_strongly_convex_qp(</div>
<div class="line">    dim, n_eq, n_in, sparsity_factor, strong_convexity_factor);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1dense_1_1QP.html">dense::QP&lt;T&gt;</a> qp(dim, n_eq, n_in); <span class="comment">// create the QP object</span></div>
<div class="line">  qp.init(qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a420a3bc7af86f6eaf6584f3f6b163e39">H</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#aab44afb08fed7665a9a1b6b76123bc2e">g</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a2faa69ae13a95d134f8f55e50935486b">A</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a35143abc2bf2a3dc4d4d0030376f00d7">b</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#ab9585ea151d2a15be6a672b2204f67a9">C</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a1e83a4aff28b7e6f81ecb962afaa6166">l</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#ab44246d2c5fd3b5bf19e1cfd6e556456">u</a>);           <span class="comment">// initialize the model</span></div>
<div class="line">  qp.settings.eps_abs = T(1.E-9); <span class="comment">// set accuracy threshold to 1.e-9</span></div>
<div class="line">  qp.settings.verbose = <span class="keyword">true</span>;     <span class="comment">// print some intermediary results</span></div>
<div class="line">  qp.solve();                     <span class="comment">// solve the problem with previous settings</span></div>
<div class="line">  <span class="comment">// print an optimal solution x,y and z</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal x: &quot;</span> &lt;&lt; qp.results.x &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal y: &quot;</span> &lt;&lt; qp.results.y &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal z: &quot;</span> &lt;&lt; qp.results.z &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment -->  </td><td valign="top"><div class="fragment"><div class="line"><span class="keyword">import</span> proxsuite</div>
<div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"><span class="keyword">import</span> scipy.sparse <span class="keyword">as</span> spa</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>generate_mixed_qp(n, seed=1):</div>
<div class="line">    <span class="comment"># A function for generating sparse random convex qps in dense format</span></div>
<div class="line"> </div>
<div class="line">    np.random.seed(seed)</div>
<div class="line">    n_eq = int(n / 4)</div>
<div class="line">    n_in = int(n / 4)</div>
<div class="line">    m = n_eq + n_in</div>
<div class="line"> </div>
<div class="line">    P = spa.random(</div>
<div class="line">        n, n, density=0.075, data_rvs=np.random.randn, format=<span class="stringliteral">&quot;csc&quot;</span></div>
<div class="line">    ).toarray()</div>
<div class="line">    P = (P + P.T) / 2.0</div>
<div class="line"> </div>
<div class="line">    s = max(np.absolute(np.linalg.eigvals(P)))</div>
<div class="line">    P += (abs(s) + 1e-02) * spa.eye(n)</div>
<div class="line">    P = spa.coo_matrix(P)</div>
<div class="line">    q = np.random.randn(n)</div>
<div class="line">    A = spa.random(m, n, density=0.15, data_rvs=np.random.randn, format=<span class="stringliteral">&quot;csc&quot;</span>).toarray()</div>
<div class="line">    v = np.random.randn(n)  <span class="comment"># Fictitious solution</span></div>
<div class="line">    delta = np.random.rand(m)  <span class="comment"># To get inequality</span></div>
<div class="line">    u = A @ v</div>
<div class="line">    l = -1.0e20 * np.ones(m)</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> P.toarray(), q, A[:n_eq, :], u[:n_eq], A[n_in:, :], u[n_in:], l[n_in:]</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment"># load a qp object using qp problem dimensions</span></div>
<div class="line">n = 10</div>
<div class="line">n_eq = 2</div>
<div class="line">n_in = 2</div>
<div class="line">qp = <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1dense_1_1QP.html">proxsuite.proxqp.dense.QP</a>(n, n_eq, n_in)</div>
<div class="line"><span class="comment"># generate a random QP</span></div>
<div class="line">H, g, A, b, C, u, l = generate_mixed_qp(n)</div>
<div class="line"><span class="comment"># initialize the model of the problem to solve</span></div>
<div class="line">qp.init(H, g, A, b, C, l, u)</div>
<div class="line">qp.settings.eps_abs = 1.0e-9</div>
<div class="line">qp.settings.verbose = <span class="keyword">True</span></div>
<div class="line"><span class="comment"># solve with previous settings</span></div>
<div class="line">qp.solve()</div>
<div class="line"><span class="comment"># print an optimal solution</span></div>
<div class="line">print(<span class="stringliteral">&quot;optimal x: {}&quot;</span>.format(qp.results.x))</div>
<div class="line">print(<span class="stringliteral">&quot;optimal y: {}&quot;</span>.format(qp.results.y))</div>
<div class="line">print(<span class="stringliteral">&quot;optimal z: {}&quot;</span>.format(qp.results.z))</div>
</div><!-- fragment -->   </td></tr>
</table>
<h2><a class="anchor" id="explanationUpdateMethod"></a>
The update method</h2>
<p >The update method is used to update the model or a parameter of the problem, as for the init method. We provide below an example for the dense case.</p>
<table class="manual">
<tr>
<th>examples/cpp/update_dense_qp.cpp </th><th>examples/python/update_dense_qp.py  </th></tr>
<tr>
<td valign="top"><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dense_8hpp.html">proxsuite/proxqp/dense/dense.hpp</a>&gt;</span> <span class="comment">// load the dense solver backend</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="random__qp__problems_8hpp.html">proxsuite/proxqp/utils/random_qp_problems.hpp</a>&gt;</span> <span class="comment">// used for generating a random convex qp</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceproxsuite_1_1proxqp.html">proxsuite::proxqp</a>;</div>
<div class="line"><span class="keyword">using </span>T = double;</div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main()</div>
<div class="line">{</div>
<div class="line">  isize dim = 10;</div>
<div class="line">  isize n_eq(dim / 4);</div>
<div class="line">  isize n_in(dim / 4);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// generate a random qp</span></div>
<div class="line">  T sparsity_factor(0.15);</div>
<div class="line">  T strong_convexity_factor(1.e-2);</div>
<div class="line">  <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html">dense::Model&lt;T&gt;</a> qp_random = utils::dense_strongly_convex_qp(</div>
<div class="line">    dim, n_eq, n_in, sparsity_factor, strong_convexity_factor);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1dense_1_1QP.html">dense::QP&lt;T&gt;</a> qp(dim, n_eq, n_in); <span class="comment">// create the QP object</span></div>
<div class="line">  qp.init(qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a420a3bc7af86f6eaf6584f3f6b163e39">H</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#aab44afb08fed7665a9a1b6b76123bc2e">g</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a2faa69ae13a95d134f8f55e50935486b">A</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a35143abc2bf2a3dc4d4d0030376f00d7">b</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#ab9585ea151d2a15be6a672b2204f67a9">C</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a1e83a4aff28b7e6f81ecb962afaa6166">l</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#ab44246d2c5fd3b5bf19e1cfd6e556456">u</a>); <span class="comment">// initialize the model</span></div>
<div class="line">  qp.solve();           <span class="comment">// solve the problem</span></div>
<div class="line">                        <span class="comment">// a new qp problem</span></div>
<div class="line">  <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html">dense::Model&lt;T&gt;</a> qp2 = utils::dense_strongly_convex_qp(</div>
<div class="line">    dim, n_eq, n_in, sparsity_factor, strong_convexity_factor);</div>
<div class="line">  <span class="comment">// re update the model</span></div>
<div class="line">  qp.update(qp2.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a420a3bc7af86f6eaf6584f3f6b163e39">H</a>, qp2.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#aab44afb08fed7665a9a1b6b76123bc2e">g</a>, qp2.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a2faa69ae13a95d134f8f55e50935486b">A</a>, qp2.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a35143abc2bf2a3dc4d4d0030376f00d7">b</a>, qp2.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#ab9585ea151d2a15be6a672b2204f67a9">C</a>, qp2.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#ab44246d2c5fd3b5bf19e1cfd6e556456">u</a>, qp2.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a1e83a4aff28b7e6f81ecb962afaa6166">l</a>);</div>
<div class="line">  <span class="comment">// solve it</span></div>
<div class="line">  qp.solve();</div>
<div class="line">  <span class="comment">// print an optimal solution x,y and z</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal x: &quot;</span> &lt;&lt; qp.results.x &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal y: &quot;</span> &lt;&lt; qp.results.y &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal z: &quot;</span> &lt;&lt; qp.results.z &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment -->  </td><td valign="top"><div class="fragment"><div class="line"><span class="keyword">import</span> proxsuite</div>
<div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"><span class="keyword">import</span> scipy.sparse <span class="keyword">as</span> spa</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>generate_mixed_qp(n, seed=1):</div>
<div class="line">    <span class="comment"># A function for generating sparse random convex qps in dense format</span></div>
<div class="line"> </div>
<div class="line">    np.random.seed(seed)</div>
<div class="line">    n_eq = int(n / 4)</div>
<div class="line">    n_in = int(n / 4)</div>
<div class="line">    m = n_eq + n_in</div>
<div class="line"> </div>
<div class="line">    P = spa.random(</div>
<div class="line">        n, n, density=0.075, data_rvs=np.random.randn, format=<span class="stringliteral">&quot;csc&quot;</span></div>
<div class="line">    ).toarray()</div>
<div class="line">    P = (P + P.T) / 2.0</div>
<div class="line"> </div>
<div class="line">    s = max(np.absolute(np.linalg.eigvals(P)))</div>
<div class="line">    P += (abs(s) + 1e-02) * spa.eye(n)</div>
<div class="line">    P = spa.coo_matrix(P)</div>
<div class="line">    q = np.random.randn(n)</div>
<div class="line">    A = spa.random(m, n, density=0.15, data_rvs=np.random.randn, format=<span class="stringliteral">&quot;csc&quot;</span>).toarray()</div>
<div class="line">    v = np.random.randn(n)  <span class="comment"># Fictitious solution</span></div>
<div class="line">    delta = np.random.rand(m)  <span class="comment"># To get inequality</span></div>
<div class="line">    u = A @ v</div>
<div class="line">    l = -1.0e20 * np.ones(m)</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> P.toarray(), q, A[:n_eq, :], u[:n_eq], A[n_in:, :], u[n_in:], l[n_in:]</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment"># load a qp object using qp problem dimensions</span></div>
<div class="line">n = 10</div>
<div class="line">n_eq = 2</div>
<div class="line">n_in = 2</div>
<div class="line">qp = <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1dense_1_1QP.html">proxsuite.proxqp.dense.QP</a>(n, n_eq, n_in)</div>
<div class="line"><span class="comment"># generate a random QP</span></div>
<div class="line">H, g, A, b, C, u, l = generate_mixed_qp(n)</div>
<div class="line"><span class="comment"># initialize the model of the problem to solve</span></div>
<div class="line">qp.init(H, g, A, b, C, l, u)</div>
<div class="line"><span class="comment"># solve without warm start</span></div>
<div class="line">qp.solve()</div>
<div class="line"><span class="comment"># create a new problem and update qp</span></div>
<div class="line">H_new, g_new, A_new, b_new, C_new, u_new, l_new = generate_mixed_qp(n, seed=2)</div>
<div class="line">qp.update(H_new, g_new, A_new, b_new, C_new, l_new, u_new)</div>
<div class="line"><span class="comment"># solve it</span></div>
<div class="line">qp.solve()</div>
<div class="line"><span class="comment"># print an optimal solution</span></div>
<div class="line">print(<span class="stringliteral">&quot;optimal x: {}&quot;</span>.format(qp.results.x))</div>
<div class="line">print(<span class="stringliteral">&quot;optimal y: {}&quot;</span>.format(qp.results.y))</div>
<div class="line">print(<span class="stringliteral">&quot;optimal z: {}&quot;</span>.format(qp.results.z))</div>
</div><!-- fragment -->   </td></tr>
</table>
<p>Contrary to the init method, the compute_preconditioner boolean parameter becomes update_preconditioner, which enables you keeping the previous preconditioner (if set to false) to equilibrate the new updated problem, or to re-compute the preconditioner with the new values of the problem (if set to true). By default the update_preconditioner parameter is set to true.</p>
<p >The major difference between the dense and sparse API is that in the sparse case only, if you change matrices of the model, the update will take effect only if the matrices have the same sparsity structure (i.e., the non zero values are located at the same place). Hence, if the matrices have a different sparsity structure, you must create a new Qp object to solve the new problem. We provide an example below.</p>
<table class="manual">
<tr>
<th>examples/cpp/update_sparse_qp.cpp </th><th>examples/python/update_sparse_qp.py  </th></tr>
<tr>
<td valign="top"><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse_8hpp.html">proxsuite/proxqp/sparse/sparse.hpp</a>&gt;</span> <span class="comment">// get the sparse API of ProxQP</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="random__qp__problems_8hpp.html">proxsuite/proxqp/utils/random_qp_problems.hpp</a>&gt;</span> <span class="comment">// used for generating a random convex qp</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceproxsuite_1_1proxqp.html">proxsuite::proxqp</a>;</div>
<div class="line"><span class="keyword">using </span>T = double;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main()</div>
<div class="line">{</div>
<div class="line">  isize n = 10;</div>
<div class="line">  isize n_eq(n / 4);</div>
<div class="line">  isize n_in(n / 4);</div>
<div class="line"> </div>
<div class="line">  T p = 0.15;            <span class="comment">// level of sparsity</span></div>
<div class="line">  T conditioning = 10.0; <span class="comment">// conditioning level for H</span></div>
<div class="line">  <span class="keyword">auto</span> H = <a class="code hl_function" href="namespaceproxsuite_1_1proxqp_1_1utils_1_1rand.html#a51eb1a46428d5c6a4ba8c97816eb3248">::proxsuite::proxqp::utils::rand::sparse_positive_definite_rand</a>(</div>
<div class="line">    n, conditioning, p);</div>
<div class="line">  <span class="keyword">auto</span> g = ::proxsuite::proxqp::utils::rand::vector_rand&lt;T&gt;(n);</div>
<div class="line">  <span class="keyword">auto</span> A = ::proxsuite::proxqp::utils::rand::sparse_matrix_rand&lt;T&gt;(n_eq, n, p);</div>
<div class="line">  <span class="keyword">auto</span> C = ::proxsuite::proxqp::utils::rand::sparse_matrix_rand&lt;T&gt;(n_in, n, p);</div>
<div class="line">  <span class="keyword">auto</span> x_sol = ::proxsuite::proxqp::utils::rand::vector_rand&lt;T&gt;(n);</div>
<div class="line">  <span class="keyword">auto</span> b = A * x_sol;</div>
<div class="line">  <span class="keyword">auto</span> l = C * x_sol;</div>
<div class="line">  <span class="keyword">auto</span> u = (l.array() + 10).matrix().eval();</div>
<div class="line">  <span class="comment">// design a qp2 object using sparsity masks of H, A and C</span></div>
<div class="line">  <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1sparse_1_1QP.html">proxsuite::proxqp::sparse::QP&lt;T, int&gt;</a> qp(</div>
<div class="line">    H.cast&lt;<span class="keywordtype">bool</span>&gt;(), A.cast&lt;<span class="keywordtype">bool</span>&gt;(), C.cast&lt;<span class="keywordtype">bool</span>&gt;());</div>
<div class="line">  qp.init(H, g, A, b, C, l, u);</div>
<div class="line">  qp.solve();</div>
<div class="line">  <span class="comment">// update H</span></div>
<div class="line">  <span class="keyword">auto</span> H_new = 2 * H; <span class="comment">// keep the same sparsity structure</span></div>
<div class="line">  qp.update(H_new,</div>
<div class="line">            std::nullopt,</div>
<div class="line">            std::nullopt,</div>
<div class="line">            std::nullopt,</div>
<div class="line">            std::nullopt,</div>
<div class="line">            std::nullopt,</div>
<div class="line">            std::nullopt); <span class="comment">// update H with H_new, it will work</span></div>
<div class="line">  qp.solve();</div>
<div class="line">  <span class="comment">// generate H2 with another sparsity structure</span></div>
<div class="line">  <span class="keyword">auto</span> H2 = <a class="code hl_function" href="namespaceproxsuite_1_1proxqp_1_1utils_1_1rand.html#a51eb1a46428d5c6a4ba8c97816eb3248">::proxsuite::proxqp::utils::rand::sparse_positive_definite_rand</a>(</div>
<div class="line">    n, conditioning, p);</div>
<div class="line">  qp.update(H2,</div>
<div class="line">            std::nullopt,</div>
<div class="line">            std::nullopt,</div>
<div class="line">            std::nullopt,</div>
<div class="line">            std::nullopt,</div>
<div class="line">            std::nullopt,</div>
<div class="line">            std::nullopt); <span class="comment">// nothing will happen</span></div>
<div class="line">  <span class="comment">// if only a vector changes, then the update takes effect</span></div>
<div class="line">  <span class="keyword">auto</span> g_new = ::proxsuite::proxqp::utils::rand::vector_rand&lt;T&gt;(n);</div>
<div class="line">  qp.update(std::nullopt,</div>
<div class="line">            g,</div>
<div class="line">            std::nullopt,</div>
<div class="line">            std::nullopt,</div>
<div class="line">            std::nullopt,</div>
<div class="line">            std::nullopt,</div>
<div class="line">            std::nullopt);</div>
<div class="line">  qp.solve(); <span class="comment">// it solves the problem with another vector</span></div>
<div class="line">  <span class="comment">// to solve the problem with H2 matrix create a new qp object</span></div>
<div class="line">  <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1sparse_1_1QP.html">proxsuite::proxqp::sparse::QP&lt;T, isize&gt;</a> qp2(</div>
<div class="line">    H2.cast&lt;<span class="keywordtype">bool</span>&gt;(), A.cast&lt;<span class="keywordtype">bool</span>&gt;(), C.cast&lt;<span class="keywordtype">bool</span>&gt;());</div>
<div class="line">  qp2.init(H2, g_new, A, b, C, l, u);</div>
<div class="line">  qp2.solve(); <span class="comment">// it will solve the new problem</span></div>
<div class="line">  <span class="comment">// print an optimal solution x,y and z</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal x: &quot;</span> &lt;&lt; qp2.results.x &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal y: &quot;</span> &lt;&lt; qp2.results.y &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal z: &quot;</span> &lt;&lt; qp2.results.z &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment -->  </td><td valign="top"><div class="fragment"><div class="line"><span class="keyword">import</span> proxsuite</div>
<div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"><span class="keyword">import</span> scipy.sparse <span class="keyword">as</span> spa</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>generate_mixed_qp(n, seed=1):</div>
<div class="line">    <span class="comment"># A function for generating random convex qps</span></div>
<div class="line"> </div>
<div class="line">    np.random.seed(seed)</div>
<div class="line">    n_eq = int(n / 4)</div>
<div class="line">    n_in = int(n / 4)</div>
<div class="line">    m = n_eq + n_in</div>
<div class="line"> </div>
<div class="line">    P = spa.random(</div>
<div class="line">        n, n, density=0.075, data_rvs=np.random.randn, format=<span class="stringliteral">&quot;csc&quot;</span></div>
<div class="line">    ).toarray()</div>
<div class="line">    P = (P + P.T) / 2.0</div>
<div class="line"> </div>
<div class="line">    s = max(np.absolute(np.linalg.eigvals(P)))</div>
<div class="line">    P += (abs(s) + 1e-02) * spa.eye(n)</div>
<div class="line">    P = spa.coo_matrix(P)</div>
<div class="line">    q = np.random.randn(n)</div>
<div class="line">    A = spa.random(m, n, density=0.15, data_rvs=np.random.randn, format=<span class="stringliteral">&quot;csc&quot;</span>)</div>
<div class="line">    v = np.random.randn(n)  <span class="comment"># Fictitious solution</span></div>
<div class="line">    delta = np.random.rand(m)  <span class="comment"># To get inequality</span></div>
<div class="line">    u = A @ v</div>
<div class="line">    l = -1.0e20 * np.ones(m)</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> P, q, A[:n_eq, :], u[:n_eq], A[n_in:, :], u[n_in:], l[n_in:]</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment"># load a qp object using qp problem dimensions</span></div>
<div class="line">n = 10</div>
<div class="line">n_eq = 2</div>
<div class="line">n_in = 2</div>
<div class="line">qp = <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1sparse_1_1QP.html">proxsuite.proxqp.sparse.QP</a>(n, n_eq, n_in)</div>
<div class="line"><span class="comment"># generate a random QP</span></div>
<div class="line">H, g, A, b, C, u, l = generate_mixed_qp(n)</div>
<div class="line"><span class="comment"># initialize the model of the problem to solve</span></div>
<div class="line">qp.init(H, g, A, b, C, l, u)</div>
<div class="line">qp.solve()</div>
<div class="line">H_new = 2 * H  <span class="comment"># keep the same sparsity structure</span></div>
<div class="line">qp.update(H_new)  <span class="comment"># update H with H_new, it will work</span></div>
<div class="line">qp.solve()</div>
<div class="line"><span class="comment"># generate a QP with another sparsity structure</span></div>
<div class="line"><span class="comment"># create a new problem and update qp</span></div>
<div class="line">H2, g_new, A_new, b_new, C_new, u_new, l_new = generate_mixed_qp(n)</div>
<div class="line">qp.update(H=H2)  <span class="comment"># nothing will happen</span></div>
<div class="line">qp.update(g=g_new)  <span class="comment"># if only a vector changes, then the update takes effect</span></div>
<div class="line">qp.solve()  <span class="comment"># it solves the problem with the QP H,g_new,A,b,C,u,l</span></div>
<div class="line"><span class="comment"># to solve the problem with H2 matrix create a new qp object in the sparse case</span></div>
<div class="line">qp2 = <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1sparse_1_1QP.html">proxsuite.proxqp.sparse.QP</a>(n, n_eq, n_in)</div>
<div class="line">qp2.init(H2, g_new, A, b, C, l, u)</div>
<div class="line">qp2.solve()  <span class="comment"># it will solve the new problem</span></div>
<div class="line"><span class="comment"># print an optimal solution</span></div>
<div class="line">print(<span class="stringliteral">&quot;optimal x: {}&quot;</span>.format(qp.results.x))</div>
<div class="line">print(<span class="stringliteral">&quot;optimal y: {}&quot;</span>.format(qp.results.y))</div>
<div class="line">print(<span class="stringliteral">&quot;optimal z: {}&quot;</span>.format(qp.results.z))</div>
</div><!-- fragment -->   </td></tr>
</table>
<p >Finally, if you want to change your initial guess option when updating the problem, you must change it in the setting before the update to take effect for the next solve (otherwise it will keep the previous one set). It is important especially for the WARM_START_WITH_PREVIOUS_RESULT initial guess option (set by default in the solver). Indeed, in this case, if no matrix is updated, the workspace keeps the previous factorization in the update method, which adds considerable speed-up for the next solve. We provide below an example in the dense case.</p>
<table class="manual">
<tr>
<th>examples/cpp/update_dense_qp_ws_previous_result.cpp </th><th>examples/python/update_dense_qp_ws_previous_result.py  </th></tr>
<tr>
<td valign="top"><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dense_8hpp.html">proxsuite/proxqp/dense/dense.hpp</a>&gt;</span> <span class="comment">// load the dense solver backend</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="random__qp__problems_8hpp.html">proxsuite/proxqp/utils/random_qp_problems.hpp</a>&gt;</span> <span class="comment">// used for generating a random convex qp</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceproxsuite.html">proxsuite</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceproxsuite_1_1proxqp.html">proxsuite::proxqp</a>;</div>
<div class="line"><span class="keyword">using </span>T = double;</div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main()</div>
<div class="line">{</div>
<div class="line">  dense::isize dim = 10;</div>
<div class="line">  dense::isize n_eq(dim / 4);</div>
<div class="line">  dense::isize n_in(dim / 4);</div>
<div class="line">  <span class="comment">// generate a random qp</span></div>
<div class="line">  T sparsity_factor(0.15);</div>
<div class="line">  T strong_convexity_factor(1.e-2);</div>
<div class="line">  <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html">dense::Model&lt;T&gt;</a> qp_random = utils::dense_strongly_convex_qp(</div>
<div class="line">    dim, n_eq, n_in, sparsity_factor, strong_convexity_factor);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1dense_1_1QP.html">dense::QP&lt;T&gt;</a> qp(dim, n_eq, n_in); <span class="comment">// create the QP object</span></div>
<div class="line">  qp.init(qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a420a3bc7af86f6eaf6584f3f6b163e39">H</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#aab44afb08fed7665a9a1b6b76123bc2e">g</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a2faa69ae13a95d134f8f55e50935486b">A</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a35143abc2bf2a3dc4d4d0030376f00d7">b</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#ab9585ea151d2a15be6a672b2204f67a9">C</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a1e83a4aff28b7e6f81ecb962afaa6166">l</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#ab44246d2c5fd3b5bf19e1cfd6e556456">u</a>); <span class="comment">// initialize the model</span></div>
<div class="line">  qp.solve();           <span class="comment">// solve the problem</span></div>
<div class="line">  <span class="comment">// re update the linear cost taking previous result</span></div>
<div class="line">  qp.settings.initial_guess =</div>
<div class="line">    InitialGuessStatus::WARM_START_WITH_PREVIOUS_RESULT;</div>
<div class="line">  <span class="comment">// it takes effect at the update because it is set before</span></div>
<div class="line">  <span class="comment">// (the workspace is not erased at the update method, hence</span></div>
<div class="line">  <span class="comment">// the previous factorization is kept)</span></div>
<div class="line">  <span class="comment">// a new linear cost slightly modified</span></div>
<div class="line">  <span class="keyword">auto</span> g = qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#aab44afb08fed7665a9a1b6b76123bc2e">g</a> * 0.95;</div>
<div class="line">  qp.update(std::nullopt,</div>
<div class="line">            g,</div>
<div class="line">            std::nullopt,</div>
<div class="line">            std::nullopt,</div>
<div class="line">            std::nullopt,</div>
<div class="line">            std::nullopt,</div>
<div class="line">            std::nullopt);</div>
<div class="line">  qp.solve();</div>
<div class="line">  <span class="comment">// print an optimal solution x,y and z</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal x: &quot;</span> &lt;&lt; qp.results.x &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal y: &quot;</span> &lt;&lt; qp.results.y &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal z: &quot;</span> &lt;&lt; qp.results.z &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceproxsuite_html"><div class="ttname"><a href="namespaceproxsuite.html">proxsuite</a></div><div class="ttdef"><b>Definition:</b> <a href="instruction-set_8hpp_source.html#l00021">instruction-set.hpp:21</a></div></div>
</div><!-- fragment -->  </td><td valign="top"><div class="fragment"><div class="line"><span class="keyword">import</span> proxsuite</div>
<div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"><span class="keyword">import</span> scipy.sparse <span class="keyword">as</span> spa</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>generate_mixed_qp(n, seed=1):</div>
<div class="line">    <span class="comment"># A function for generating sparse random convex qps in dense format</span></div>
<div class="line"> </div>
<div class="line">    np.random.seed(seed)</div>
<div class="line">    n_eq = int(n / 4)</div>
<div class="line">    n_in = int(n / 4)</div>
<div class="line">    m = n_eq + n_in</div>
<div class="line"> </div>
<div class="line">    P = spa.random(</div>
<div class="line">        n, n, density=0.075, data_rvs=np.random.randn, format=<span class="stringliteral">&quot;csc&quot;</span></div>
<div class="line">    ).toarray()</div>
<div class="line">    P = (P + P.T) / 2.0</div>
<div class="line"> </div>
<div class="line">    s = max(np.absolute(np.linalg.eigvals(P)))</div>
<div class="line">    P += (abs(s) + 1e-02) * spa.eye(n)</div>
<div class="line">    P = spa.coo_matrix(P)</div>
<div class="line">    q = np.random.randn(n)</div>
<div class="line">    A = spa.random(m, n, density=0.15, data_rvs=np.random.randn, format=<span class="stringliteral">&quot;csc&quot;</span>).toarray()</div>
<div class="line">    v = np.random.randn(n)  <span class="comment"># Fictitious solution</span></div>
<div class="line">    delta = np.random.rand(m)  <span class="comment"># To get inequality</span></div>
<div class="line">    u = A @ v</div>
<div class="line">    l = -1.0e20 * np.ones(m)</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> P.toarray(), q, A[:n_eq, :], u[:n_eq], A[n_in:, :], u[n_in:], l[n_in:]</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment"># load a qp object using qp problem dimensions</span></div>
<div class="line">n = 10</div>
<div class="line">n_eq = 2</div>
<div class="line">n_in = 2</div>
<div class="line">qp = <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1dense_1_1QP.html">proxsuite.proxqp.dense.QP</a>(n, n_eq, n_in)</div>
<div class="line"><span class="comment"># generate a random QP</span></div>
<div class="line">H, g, A, b, C, u, l = generate_mixed_qp(n)</div>
<div class="line"><span class="comment"># initialize the model of the problem to solve</span></div>
<div class="line">qp.init(H, g, A, b, C, l, u)</div>
<div class="line"><span class="comment"># solve without warm start</span></div>
<div class="line">qp.solve()</div>
<div class="line"><span class="comment"># create a new problem and update qp</span></div>
<div class="line">g_new = 0.95 * g  <span class="comment"># slightly different g_new</span></div>
<div class="line">qp.settings.initial_guess = (</div>
<div class="line">    proxsuite.proxqp.InitialGuess.WARM_START_WITH_PREVIOUS_RESULT</div>
<div class="line">)</div>
<div class="line">qp.update(g=g_new)</div>
<div class="line"><span class="comment"># solve it</span></div>
<div class="line">qp.solve()</div>
<div class="line"><span class="comment"># print an optimal solution</span></div>
<div class="line">print(<span class="stringliteral">&quot;optimal x: {}&quot;</span>.format(qp.results.x))</div>
<div class="line">print(<span class="stringliteral">&quot;optimal y: {}&quot;</span>.format(qp.results.y))</div>
<div class="line">print(<span class="stringliteral">&quot;optimal z: {}&quot;</span>.format(qp.results.z))</div>
</div><!-- fragment -->   </td></tr>
</table>
<p >Note that one subsection is dedicated to the different initial guess options below.</p>
<h1><a class="anchor" id="OverviewSettings"></a>
The settings subclass</h1>
<p >In this section you will find first the solver's settings, and then a subsection detailing the different initial guess options.</p>
<h2><a class="anchor" id="OverviewAllSettings"></a>
The solver's settings</h2>
<p >In this table you have on the three columns from left to right: the name of the setting, its default value and then a short description of it.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Setting   </th><th class="markdownTableHeadNone">Default value   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">eps_abs   </td><td class="markdownTableBodyNone">1.E-3   </td><td class="markdownTableBodyNone">Asbolute stopping criterion of the solver.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">eps_rel   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">Relative stopping criterion of the solver.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">VERBOSE   </td><td class="markdownTableBodyNone">False   </td><td class="markdownTableBodyNone">If set to true, the solver prints information at each loop.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">default_rho   </td><td class="markdownTableBodyNone">1.E-6   </td><td class="markdownTableBodyNone">Default rho parameter of result class (i.e., for each initial guess, except WARM_START_WITH_PREVIOUS_RESULT, after a new solve or update, the solver initializes rho to this value).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">default_mu_eq   </td><td class="markdownTableBodyNone">1.E-3   </td><td class="markdownTableBodyNone">Default mu_eq parameter of result class (i.e., for each initial guess, except WARM_START_WITH_PREVIOUS_RESULT, after a new solve or update, the solver initializes mu_eq to this value).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">default_mu_in   </td><td class="markdownTableBodyNone">1.E-1   </td><td class="markdownTableBodyNone">Default mu_in parameter of result class (i.e., for each initial guess, except WARM_START_WITH_PREVIOUS_RESULT, after a new solve or update, the solver initializes mu_in to this value).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">compute_timings   </td><td class="markdownTableBodyNone">True   </td><td class="markdownTableBodyNone">If set to true, timings will be computed by the solver (setup time, solving time, and run time = setup time + solving time).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">max_iter   </td><td class="markdownTableBodyNone">1.E4   </td><td class="markdownTableBodyNone">Maximal number of authorized outer iterations.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">max_iter_in   </td><td class="markdownTableBodyNone">1500   </td><td class="markdownTableBodyNone">Maximal number of authorized inner iterations.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">initial_guess   </td><td class="markdownTableBodyNone">WARM_START_WITH_PREVIOUS_RESULT   </td><td class="markdownTableBodyNone">Sets the initial guess option for initilizing x, y and z.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">mu_min_eq   </td><td class="markdownTableBodyNone">1.E-9   </td><td class="markdownTableBodyNone">Minimal authorized value for mu_eq.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">mu_min_in   </td><td class="markdownTableBodyNone">1.E-8   </td><td class="markdownTableBodyNone">Minimal authorized value for mu_in.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">mu_update_factor   </td><td class="markdownTableBodyNone">0.1   </td><td class="markdownTableBodyNone">Factor used for updating mu_eq and mu_in.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">eps_primal_inf   </td><td class="markdownTableBodyNone">1.E-4   </td><td class="markdownTableBodyNone">Threshold under which primal infeasibility is detected.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">eps_dual_inf   </td><td class="markdownTableBodyNone">1.E-4   </td><td class="markdownTableBodyNone">Threshold under which dual infeasibility is detected.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">update_preconditioner   </td><td class="markdownTableBodyNone">True   </td><td class="markdownTableBodyNone">If set to true, the preconditioner will be re-derived with the update method, otherwise it uses previous one.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">compute_preconditioner   </td><td class="markdownTableBodyNone">True   </td><td class="markdownTableBodyNone">If set to true, the preconditioner will be derived with the init method.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">alpha_bcl   </td><td class="markdownTableBodyNone">0.1   </td><td class="markdownTableBodyNone">alpha parameter of the BCL algorithm.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">beta_bcl   </td><td class="markdownTableBodyNone">0.9   </td><td class="markdownTableBodyNone">beta parameter of the BCL algorithm.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">refactor_dual_feasibility_threshold   </td><td class="markdownTableBodyNone">1.E-2   </td><td class="markdownTableBodyNone">Threshold above which refactorization is performed to change rho parameter.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">refactor_rho_threshold   </td><td class="markdownTableBodyNone">1.E-7   </td><td class="markdownTableBodyNone">New rho parameter used if the refactor_dual_feasibility_threshold condition has been satisfied.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">cold_reset_mu_eq   </td><td class="markdownTableBodyNone">1./1.1   </td><td class="markdownTableBodyNone">Value used for cold restarting mu_eq.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cold_reset_mu_in   </td><td class="markdownTableBodyNone">1./1.1   </td><td class="markdownTableBodyNone">Value used for cold restarting mu_in.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">nb_iterative_refinement   </td><td class="markdownTableBodyNone">10   </td><td class="markdownTableBodyNone">Maximal number of iterative refinements.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">eps_refact   </td><td class="markdownTableBodyNone">1.E-6   </td><td class="markdownTableBodyNone">Threshold value below which the ldlt is refactorized factorization in the iterative refinement loop.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">safe_guard   </td><td class="markdownTableBodyNone">1.E4   </td><td class="markdownTableBodyNone">Safeguard parameter ensuring global convergence of the scheme. More precisely, if the total number of iteration is superior to safe_guard, the BCL scheme accept always the multipliers (hence the scheme is a pure proximal point algorithm).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">preconditioner_max_iter   </td><td class="markdownTableBodyNone">10   </td><td class="markdownTableBodyNone">Maximal number of authorized iterations for the preconditioner.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">preconditioner_accuracy   </td><td class="markdownTableBodyNone">1.E-3   </td><td class="markdownTableBodyNone">Accuracy level of the preconditioner.   </td></tr>
</table>
<h2><a class="anchor" id="OverviewInitialGuess"></a>
The different initial guesses</h2>
<p >The solver has five different possible initial guesses for warm starting or not the initial iterate values:</p><ul>
<li>NO_INITIAL_GUESS,</li>
<li>EQUALITY_CONSTRAINED_INITIAL_GUESS,</li>
<li>WARM_START_WITH_PREVIOUS_RESULT,</li>
<li>WARM_START,</li>
<li>COLD_START_WITH_PREVIOUS_RESULT.</li>
</ul>
<p >The different options will be commented below in the introduced order above.</p>
<h3><a class="anchor" id="OverviewNoInitialGuess"></a>
No initial guess</h3>
<p >If set to this option, the solver will start with no initial guess, which means that the initial values of x, y and z are the 0 vector.</p>
<h3><a class="anchor" id="OverviewEqualityConstrainedInitialGuess"></a>
Equality constrained initial guess</h3>
<p >If set to this option, the solver will solve at the beginning the following system for warm starting x and y. $$\begin{bmatrix} H+\rho I &amp; A^T \\ A &amp; -\mu_{eq} I \end{bmatrix} \begin{bmatrix} x \\ y \end{bmatrix} = \begin{bmatrix} -g \\ b \end{bmatrix}$$ z stays to 0. In general this option warm starts well equality constrained QP.</p>
<h3><a class="anchor" id="OverviewWarmStartWithPreviousResult"></a>
Warm start with previous result</h3>
<p >If set to this option, the solver will warm start x, y and z with the values of the previous problem solved and it will keep all the last parameters of the solver (i.e., proximal step sizes for example, and the full workspace with the ldlt factorization etc.). Hence, if the new problem to solve is the same as the previous one, the problem is warm started at the solution (and zero iteration will be executed).</p>
<p >This option has been thought initially for being used in optimal control like problems, when the next problem to be solved is closed to the previous one. Indeed, if the problem changes only slightly, it is reasonable to warm start the new problem with the value of the previous one for speeding the whole runtime.</p>
<p >Note however, that if your update involves new matrices or that you decide to change parameters involved in the ldlt factorization (i.e., the proximal step sizes), then for consistency, the solver will automatically refactorize the ldlt with these updates (and taking into account the last values of x, y and z for the active set).</p>
<p >Finally, note that this option is set by default in the solver. At the first solve, as there is no previous results, x, y and z are warm started with the 0 vector value.</p>
<h3><a class="anchor" id="OverviewWarmStart"></a>
Warm start</h3>
<p >If set to this option, the solver expects then a warm start at the solve method.</p>
<p >Note, that it is not necessary to set this option through the command below (for example in C++) before the update or solve method call. </p><div class="fragment"><div class="line">Qp.settings.initial_guess = proxsuite::qp::InitialGuessStatus::WARM_START;</div>
</div><!-- fragment --><p >It is sufficient to just add the warm start in the solve method, and the solver will automatically make the setting change internally.</p>
<h3><a class="anchor" id="OverviewColdStartWithPreviousResult"></a>
Cold start with previous result</h3>
<p >If set to this option, the solver will warm start x, y and z with the values of the previous problem solved. Contrary to the WARM_START_WITH_PREVIOUS_RESULT option, all other parameters of the solver (i.e., proximal step sizes for example, and the full workspace with the ldlt factorization etc.) are re-set to their default values (hence a factorization is reperformed taking into account of z warm start for the active set, but with default values of proximal step sizes).</p>
<p >This option has also been thought initially for being used in optimal control like problems, when the next problem to be solved is closed to the previous one. Indeed, if the problem changes only slightly, it is reasonable to warm start the new problem with the value of the previous one for speeding the whole runtime.</p>
<p >Note finally that at the first solve, as there is no previous results, x, y and z are warm started with the 0 vector value.</p>
<h1><a class="anchor" id="OverviewResults"></a>
The results subclass</h1>
<p >The result subclass is composed of:</p><ul>
<li>x: a primal solution,</li>
<li>y: a Lagrange optimal multiplier for equality constraints,</li>
<li>z: a Lagrange optimal multiplier for inequality constraints,</li>
<li>info: a subclass which containts some information about the solver's execution.</li>
</ul>
<p >If the solver has solved the problem, the triplet (x,y,z) satisfies:</p>
<p >$$\begin{equation}\label{eq:approx_qp_sol_rel} \begin{aligned} &amp;\left\{ \begin{array}{ll} |Hx+g+A^Ty+C^Tz|_{\infty} \leq \epsilon_{\text{abs}} + \epsilon_{\text{rel}}\max(|Hx|_{\infty},|A^Ty|_{\infty},|C^Tz|_{\infty},|g|_{\infty}), \\ |Ax-b|_{\infty} \leq \epsilon_{\text{abs}} +\epsilon_{\text{rel}}\max(|Ax|_{\infty},|b|_{\infty}), \\ |[Cx-u]_+|_{\infty}\leq \epsilon_{\text{abs}} +\epsilon_{\text{rel}}\max(|Cx|_{\infty},|u|_{\infty}), \\ \end{array} \right. \end{aligned} \end{equation}$$ accordingly with the parameters eps_abs and eps_rel chosen by the user.</p>
<h2><a class="anchor" id="OverviewInfoClass"></a>
The info subclass</h2>
<p >In this table you have on the three columns from left to right: the name of the info subclass item, its default value and then a short description of it.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Info item   </th><th class="markdownTableHeadNone">Default value   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">mu_eq   </td><td class="markdownTableBodyNone">1.E-3   </td><td class="markdownTableBodyNone">Proximal step size wrt equality constraints multiplier.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">mu_in   </td><td class="markdownTableBodyNone">1.E-1   </td><td class="markdownTableBodyNone">Proximal step size wrt inequality constraints multiplier.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">rho   </td><td class="markdownTableBodyNone">1.E-6   </td><td class="markdownTableBodyNone">Proximal step size wrt primal variable.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">iter   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">Total number of iterations.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">iter_ext   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">Total number of outer iterations.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">mu_updates   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">Total number of mu updates.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">rho_updates   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">Total number of rho updates.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">status   </td><td class="markdownTableBodyNone">PROXQP_MAX_ITER_REACHED   </td><td class="markdownTableBodyNone">Status of the solver.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">setup_time   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">Setup time (takes into account the equlibration procedure).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">solve_time   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">Solve time (takes into account the first factorization).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">run_time   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">the sum of the setupe time and the solve time.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">objValue   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">The objective value to minimize.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">pri_res   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">The primal residual.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">dua_res   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">The dual residual.   </td></tr>
</table>
<p >Note finally that when initializing a QP object, by default the proximal step sizes (i.e., rho, mu_eq and mu_in) are set up by the default values defined in the Setting class. Hence, when doing multiple solves, if not specified, their values are re-set respectively to default_rho, default_mu_eq and default_mu_in. A small example is given below in c++ and python.</p>
<table class="manual">
<tr>
<th>examples/cpp/init_with_default_options.cpp </th><th>examples/python/init_with_default_options.py  </th></tr>
<tr>
<td valign="top"><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dense_8hpp.html">proxsuite/proxqp/dense/dense.hpp</a>&gt;</span> <span class="comment">// load the dense solver backend</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="random__qp__problems_8hpp.html">proxsuite/proxqp/utils/random_qp_problems.hpp</a>&gt;</span> <span class="comment">// used for generating a random convex qp</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceproxsuite_1_1proxqp.html">proxsuite::proxqp</a>;</div>
<div class="line"><span class="keyword">using </span>T = double;</div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main()</div>
<div class="line">{</div>
<div class="line">  isize dim = 10;</div>
<div class="line">  isize n_eq(dim / 4);</div>
<div class="line">  isize n_in(dim / 4);</div>
<div class="line">  <span class="comment">// generate a random qp</span></div>
<div class="line">  T sparsity_factor(0.15);</div>
<div class="line">  T strong_convexity_factor(1.e-2);</div>
<div class="line">  <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html">dense::Model&lt;T&gt;</a> qp_random = utils::dense_strongly_convex_qp(</div>
<div class="line">    dim, n_eq, n_in, sparsity_factor, strong_convexity_factor);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1dense_1_1QP.html">dense::QP&lt;T&gt;</a> qp(</div>
<div class="line">    dim, n_eq, n_in); <span class="comment">// create the QP</span></div>
<div class="line">                      <span class="comment">// initialize the model, along with another rho parameter</span></div>
<div class="line">  qp.settings.initial_guess = InitialGuessStatus::NO_INITIAL_GUESS;</div>
<div class="line">  qp.init(qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a420a3bc7af86f6eaf6584f3f6b163e39">H</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#aab44afb08fed7665a9a1b6b76123bc2e">g</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a2faa69ae13a95d134f8f55e50935486b">A</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a35143abc2bf2a3dc4d4d0030376f00d7">b</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#ab9585ea151d2a15be6a672b2204f67a9">C</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a1e83a4aff28b7e6f81ecb962afaa6166">l</a>,</div>
<div class="line">          qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#ab44246d2c5fd3b5bf19e1cfd6e556456">u</a>,</div>
<div class="line">          <span class="keyword">true</span>,</div>
<div class="line">          <span class="comment">/*rho*/</span> 1.e-7,</div>
<div class="line">          <span class="comment">/*mu_eq*/</span> 1.e-4);</div>
<div class="line">  <span class="comment">// Initializing rho sets in practive qp.settings.default_rho value,</span></div>
<div class="line">  <span class="comment">// hence, after each solve or update method, the qp.results.info.rho value</span></div>
<div class="line">  <span class="comment">// will be reset to qp.settings.default_rho value.</span></div>
<div class="line">  qp.solve();</div>
<div class="line">  <span class="comment">// So if we redo a solve, qp.settings.default_rho value = 1.e-7, hence</span></div>
<div class="line">  <span class="comment">// qp.results.info.rho restarts at 1.e-7 The same occurs for mu_eq.</span></div>
<div class="line">  qp.solve();</div>
<div class="line">  <span class="comment">// There might be a different result with WARM_START_WITH_PREVIOUS_RESULT</span></div>
<div class="line">  <span class="comment">// initial guess option, as by construction, it reuses the last proximal step</span></div>
<div class="line">  <span class="comment">// sizes of the last solving method.</span></div>
<div class="line">}</div>
</div><!-- fragment -->  </td><td valign="top"><div class="fragment"><div class="line"><span class="keyword">import</span> proxsuite</div>
<div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"><span class="keyword">import</span> scipy.sparse <span class="keyword">as</span> spa</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>generate_mixed_qp(n, seed=1):</div>
<div class="line">    <span class="comment"># A function for generating random convex qps</span></div>
<div class="line"> </div>
<div class="line">    np.random.seed(seed)</div>
<div class="line">    n_eq = int(n / 4)</div>
<div class="line">    n_in = int(n / 4)</div>
<div class="line">    m = n_eq + n_in</div>
<div class="line"> </div>
<div class="line">    P = spa.random(</div>
<div class="line">        n, n, density=0.075, data_rvs=np.random.randn, format=<span class="stringliteral">&quot;csc&quot;</span></div>
<div class="line">    ).toarray()</div>
<div class="line">    P = (P + P.T) / 2.0</div>
<div class="line"> </div>
<div class="line">    s = max(np.absolute(np.linalg.eigvals(P)))</div>
<div class="line">    P += (abs(s) + 1e-02) * spa.eye(n)</div>
<div class="line">    P = spa.coo_matrix(P)</div>
<div class="line">    q = np.random.randn(n)</div>
<div class="line">    A = spa.random(m, n, density=0.15, data_rvs=np.random.randn, format=<span class="stringliteral">&quot;csc&quot;</span>).toarray()</div>
<div class="line">    v = np.random.randn(n)  <span class="comment"># Fictitious solution</span></div>
<div class="line">    delta = np.random.rand(m)  <span class="comment"># To get inequality</span></div>
<div class="line">    u = A @ v</div>
<div class="line">    l = -1.0e20 * np.ones(m)</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> P.toarray(), q, A[:n_eq, :], u[:n_eq], A[n_in:, :], u[n_in:], l[n_in:]</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment"># load a qp object using qp problem dimensions</span></div>
<div class="line">n = 10</div>
<div class="line">n_eq = 2</div>
<div class="line">n_in = 2</div>
<div class="line">qp = <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1dense_1_1QP.html">proxsuite.proxqp.dense.QP</a>(n, n_eq, n_in)</div>
<div class="line"><span class="comment"># generate a random QP</span></div>
<div class="line">H, g, A, b, C, u, l = generate_mixed_qp(n)</div>
<div class="line"><span class="comment"># initialize the model of the problem to solve</span></div>
<div class="line">qp.init(H, g, A, b, C, l, u, rho=1.0e-7, mu_eq=1.0e-4)</div>
<div class="line">qp.solve()</div>
<div class="line"><span class="comment"># If we redo a solve, qp.settings.default_rho value = 1.e-7, hence qp.results.info.rho restarts at 1.e-7</span></div>
<div class="line"><span class="comment"># The same occurs for mu_eq.</span></div>
<div class="line">qp.solve()</div>
<div class="line"><span class="comment"># There might be a different result with WARM_START_WITH_PREVIOUS_RESULT initial guess option, as</span></div>
<div class="line"><span class="comment"># by construction, it reuses the last proximal step sizes of the last solving method.</span></div>
</div><!-- fragment -->   </td></tr>
</table>
<h2><a class="anchor" id="OverviewSolverStatus"></a>
The solver's status</h2>
<p >The solver has four status:</p><ul>
<li>PROXQP_SOLVED: the problem is solved.</li>
<li>PROXQP_MAX_ITER_REACHED: the maximum number of iterations has been reached.</li>
<li>PROXQP_PRIMAL_INFEASIBLE: the problem is primal infeasible.</li>
<li>PROXQP_DUAL_INFEASIBLE: the problem is dual infeasible.</li>
</ul>
<p >Infeasibility is detected using the necessary conditions exposed in <a href="https://web.stanford.edu/~boyd/papers/pdf/osqp.pdf">section 3.4</a>. More precisely, primal infeasibility is assumed if the following conditions are matched for some non zeros dy and dz (according the eps_prim_inf variable set by the user):</p>
<p >$$\begin{equation}\label{eq:approx_qp_sol_prim_inf}\tag{PrimalInfeas} \begin{aligned} &amp;\left\{ \begin{array}{ll} |A^Tdy|_{\infty} \leq \epsilon_{\text{primal_inf}} |dy|_{\infty} , \\ b^T dy \leq -\epsilon_{\text{primal_inf}} |dy|_{\infty}, \\ |C^Tdz|_{\infty} \leq \epsilon_{\text{primal_inf}} |dz|_{\infty}, \\ u^T [dz]_+ - l^T[-dz]_+\leq -\epsilon_{\text{primal_inf}} |dz|_{\infty}. \\ \end{array} \right. \end{aligned} \end{equation}$$</p>
<p >Dual infeasibility is assumed if the following two conditions are matched for some non zero dx (according the eps_dual_inf variable set by the user):</p>
<p >$$\begin{equation}\label{eq:approx_qp_sol_dual_inf}\tag{DualInfeas} \begin{aligned} &amp;\left\{ \begin{array}{ll} |Hdx|_{\infty} \leq \epsilon_{\text{dual_inf}} |dx|_{\infty} , \\ g^T dx \leq -\epsilon_{\text{dual_inf}} |dx|_{\infty}, \\ |Adx|_{\infty}\leq \epsilon_{\text{dual_inf}} |dx|_{\infty}, \\ (Cdz)_i \geq \epsilon_{\text{dual_inf}} |dx|_{\infty}, \mbox{ if } u_i = +\infty, \\ (Cdz)_i \leq \epsilon_{\text{dual_inf}} |dx|_{\infty}, \mbox{ otherwise }. \end{array} \right. \end{aligned} \end{equation}$$</p>
<p >If the problem turns out to be primal or dual infeasible, then x, y and z stored in the results class will be the certificate of primal or dual infeasibility. More precisely:</p><ul>
<li>if the problem is dual infeasible, Qp.results.x will be the certificate dx of dual infeasibility satisfying \eqref{eq:approx_qp_sol_dual_inf} at precisifion Qp.settings.eps_dual_inf specified by the user,</li>
<li>if the problem is primal infeasible, Qp.results.y and and Qp.results.z will be respectively the certificates dy and dz of primal infeasibility satisfying \eqref{eq:approx_qp_sol_prim_inf} at precisifion Qp.settings.eps_primal_inf specified by the user.</li>
</ul>
<h1><a class="anchor" id="OverviewWhichBackend"></a>
Which backend to use?</h1>
<p >We have the following generic advices for choosing between the sparse and dense backend. If your problem is not:</p><ul>
<li>too large (less than some thousands variables),</li>
<li>and too sparse (a sparsity ratio of your matrices greater than 0.1),</li>
</ul>
<p >then we recommand using the solver with dense backend.</p>
<p >The sparsity ratio of matrix A is defined as:</p>
<p >$$ \text{sparsity}(A) = \frac{\text{nnz}(A)}{\text{number}_{\text{row}}(A) * \text{number}_{\text{col}}(A)}, $$</p>
<p >which accounts for the percentage of non zero elements in matrix A.</p>
<h1><a class="anchor" id="OverviewBenchmark"></a>
Some important remarks when computing timings</h1>
<p >We provide first some details about what is measured in the setup and solve time of ProxQP, which is of some importance when doing benchmarks with other solvers, as they can measure different things in a feature with a similar name.</p>
<p >Then we conclude this documentation section with some compilation options for ProxQP which can considerably speed up the solver, considering your OS architecture.</p>
<h2><a class="anchor" id="OverviewTimings"></a>
What do the timings take into account?</h2>
<p >An important remark about quadratic programming solver is that they all rely at some point on a factorization matrix algorithm, which constitutes the time bottle neck of the solver (as the factorization has a cubic order of complexity wrt dimension of the matrix to factorize).</p>
<p >Available solvers have often a similar API as the one we propose, with first an "init" method for initializing the model, and then a "solve" method for solving the QP problem. For not biasing the benchmarks, it is important to know where is done the first matrix factorization, as it constitutes a considerable cost. In our API, we have decided to make the first factorization in the solve method, as we consider that factorizing the problem is part of the solving part. Hence in terms of timing:</p><ul>
<li>results.info.setup_time: measures only the initialization of the model and also the preconditioning procedure (if it has been activated),</li>
<li>results.info.solve_time: measures everything else (including the first factorization),</li>
<li>results.info.run_time = results.info.setup_time + results.info.solve_time.</li>
</ul>
<p >It is important to notice that some other solvers API have made different choices. For example, OSQP measures in the setup time the first factorization of the system (at the time <a href="https://hal.inria.fr/hal-03683733/file/Yet_another_QP_solver_for_robotics_and_beyond.pdf">ProxQP algorithm</a> was published). Hence our recommandation is that for benchmarking ProxQP against other solvers you should compare ProxQP runtime against the other solvers' runtime (i.e., everything from what constitutes their setup to their solve method). Otherwise, the benchmarks won't take into account timings that are comparable.</p>
<h2><a class="anchor" id="OverviewArchitectureOptions"></a>
Architecture options when compiling ProxSuite</h2>
<p >We highly encourage you to enable the vectorization of the underlying linear algebra for the best performances. You just need to activate the cmake option <code>BUILD_WITH_SIMD_SUPPORT=ON</code>, like:</p>
<div class="fragment"><div class="line">mkdir build &amp;&amp; cd build</div>
<div class="line">cmake .. -DCMAKE_BUILD_TYPE=Release -DBUILD_TESTING=OFF -DBUILD_WITH_SIMD_SUPPORT=ON</div>
<div class="line">make</div>
<div class="line">make install</div>
</div><!-- fragment --><p >ProxQP can be compiled more precisely with two SIMD instructions options for x86 instruction set architectures: <a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX-2</a> and <a href="https://en.wikipedia.org/wiki/AVX-512">AVX-512</a>. They can considerably enhance the speed of ProxQP, and we encourage you to use them if your OS is compatible with them. For your information, our benchmarks for <a href="https://hal.inria.fr/hal-03683733/file/Yet_another_QP_solver_for_robotics_and_beyond.pdf">ProxQP algorithm</a> have been realised with AVX-2 compilation option. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.5-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
