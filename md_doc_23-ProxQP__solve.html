<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>proxsuite: ProxQP solve function without API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/SVG"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeDarkModeToggle.init()
    </script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">proxsuite<span id="projectnumber">&#160;0.6.3</span>
   </div>
   <div id="projectbrief">The Advanced Proximal Optimization Toolbox</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_doc_23-ProxQP__solve.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">ProxQP solve function without API</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md1"></a> ProxQP solves convex quadratic programs, which consists in minimizing a convex quadratic cost under some linear constraints. It is mathematically described as:</p>
<p>$$\begin{equation}\label{eq:QP}\tag{QP} \begin{aligned} \min_{x\in\mathbb{R}^{d}} &amp; \quad \frac{1}{2}x^{T}Hx+g^{T}x \\ \text{s.t.}&amp;\left\{ \begin{array}{ll} Ax = b, \\ Cx \leq u. \\ \end{array} \right. \end{aligned} \end{equation}\\ \text{with } H\in\mathbb{R}^{d\times d}, A\in\mathbb{R}^{n_\text{eq}\times d}, C\in\mathbb{R}^{n_\text{in}\times d}, b\in\mathbb{R}^{n_\text{eq}}, u\in\mathbb{R}^{n_\text{in}}. $$ H is a real symmetric positive semi-definite matrix. d is the problem dimension (i.e., the number of primal variables), while n_eq and n_in are the numbers of equality and inequality constraints respectively.</p>
<p>For linearly constrained convex optimization problems such as \eqref{eq:QP}, strong duality holds and the associated KKT conditions are necessary and sufficient for ensuring a primal-dual point (x,y,z) to be optimal (see, e.g.,<a href="https://web.stanford.edu/~boyd/cvxbook/">Section 5.2.3</a>} and <a href="https://web.stanford.edu/~boyd/papers/pdf/osqp.pdf">Section 2, page 5</a> for more details). For \eqref{eq:QP}, the KKT system is given by the set of equations:</p>
<p>$$\begin{equation}\label{qp:kkt}\tag{KKT} \begin{aligned} &amp;\left\{ \begin{array}{ll} Hx+g+A^Ty+C^Tz = 0, \\ Ax-b = 0, \\ Cx \leq u, \\ z\odot[Cx-u] = 0,\\ \end{array} \right. \end{aligned} \end{equation}$$</p>
<p>where the last equation involves the Hadamard product (i.e., for two vectors u and v, the Hadamard product is the vector whose ith entry is u_i v_i).</p>
<p>In practice, we look for a triplet (x,y,z) satisfying these optimality conditions \eqref{qp:kkt} up to a certain level of absolute accuracy (dependent of the application), leading us to the following absolute stopping criterion on the primal and dual residuals:</p>
<p>$$\begin{equation}\label{eq:approx_qp_sol} \begin{aligned} &amp;\left\{ \begin{array}{ll} |Hx+g+A^Ty+C^Tz|_{\infty} \leq \epsilon_{abs}, \\ |Ax-b|_{\infty} \leq \epsilon_{abs}, \\ |[Cx-u]_+|_{\infty}\leq \epsilon_{abs}. \\ \end{array} \right. \end{aligned} \end{equation}$$</p>
<p>The infite norm is preferred to the L2 norm as it is independent of the problem dimensions. It is also common to consider relative convergence criteria for early-stopping, as absolute targets might not bet reached due to numerical issues. ProxQP provides it in a similar way as OSQP (for more details see, e.g., OSQP's <a href="https://osqp.org/docs/solver/index.html#convergence">convergence</a> criteria or <a href="https://web.stanford.edu/~boyd/papers/pdf/osqp.pdf">section 3.4</a> in the corresponding paper). Hence more generally the following stopping criterion can be used:</p>
<p>$$\begin{equation}\label{eq:approx_qp_sol_relative_criterion} \begin{aligned} &amp;\left\{ \begin{array}{ll} |Hx+g+A^Ty+C^Tz|_{\infty} \leq \epsilon_{\text{abs}} + \epsilon_{\text{rel}}\max(|Hx|_{\infty},|A^Ty|_{\infty},|C^Tz|_{\infty},|g|_{\infty}), \\ |Ax-b|_{\infty} \leq \epsilon_{\text{abs}} +\epsilon_{\text{rel}}\max(|Ax|_{\infty},|b|_{\infty}), \\ |[Cx-u]_+|_{\infty}\leq \epsilon_{\text{abs}} +\epsilon_{\text{rel}}\max(|Cx|_{\infty},|u|_{\infty}). \\ \end{array} \right. \end{aligned} \end{equation}$$</p>
<p>It is important to note that this stopping criterion on primal and dual residuals is not enough to guarantee that the returned solution satisfies all \eqref{qp:kkt} conditions. Indeed, as the problem has affine constraints and the objective is quadratic and convex, then as soon as the primal or the dual problem is feasible, then strong duality holds (see e.g., <a href="https://people.eecs.berkeley.edu/~elghaoui/Teaching/EE227A/lecture8.pdf">Theorem 2</a> from L. El Ghaoui's lesson) and to satisfy all optimality conditions we need to add a third criterion on the <em>duality gap</em> \(r_g\):</p>
<p>$$\begin{equation}\label{eq:approx_dg_sol} \begin{aligned} r_g := | x^T H x + g^T x + b^T y + u^T [z]_+ + l^T [z]_- | \leq \epsilon^{\text{gap}}_{\text{abs}} + \epsilon^{\text{gap}}_{\text{rel}} \max(|x^T H x|, |g^T x|, |b^T y|, |u^T [z]_+|, |l^T [z]_-|), \ \end{aligned} \end{equation}$$</p>
<p>where \([z]_+\) and \([z]_-\) stand for the projection of z onto the positive and negative orthant. ProxQP provides the <code>check_duality_gap</code> option to include this duality gap in the stopping criterion. Note that it is disabled by default, as other solvers don't check in general this criterion. Enable this option if you want a stronger guarantee that your solution is optimal. ProxQP will then check the same termination condition as SCS (for more details see, e.g., SCS's <a href="https://www.cvxgrp.org/scs/algorithm/index.html#optimality-conditions">optimality conditions checks</a> as well as <a href="https://doi.org/10.1137/20M1366307">section 7.2</a> in the corresponding paper). The absolute and relative thresholds \(\epsilon^{\text{gap}}_{\text{abs}}, \epsilon^{\text{gap}}_{\text{rel}}\) for the duality gap can differ from those \(\epsilon_{\text{abs}}, \epsilon_{\text{rel}}\) for residuals because, contrary to residuals which result from an infinite norm, the duality gap scales with the square root of the problem dimension (thus it is numerically harder to achieve a given duality gap for larger problems). A recommended choice is \(\epsilon^{\text{gap}}_{\text{abs}} = \epsilon_{\text{abs}} \sqrt{\max(n, n_{\text{eq}}, n_{\text{ineq}})}\). Note finally that meeting all residual and duality-gap criteria can be difficult for ill-conditioned problems.</p>
<h1><a class="anchor" id="OverviewAsingleSolveFunction"></a>
A single solve function for dense and sparse backends</h1>
<p>If if you don't want to pass through <a class="el" href="md_doc_22-ProxQP__api.html">ProxQP API</a>, it is also possible to use one single solve function. We will show how to do so with examples.</p>
<p>You just need to call a "solve" function with in entry the model of the convex QP you want to solve. We show you below examples in C++ and python for ProxQP sparse and dense backends. Note that the sparse and dense solvers take respectivaly entries in sparse and dense formats. Note finally that the dense backend benefits from a feature enabling it to handle more efficiently box inequality constraints. We provide an example below as well of how using it (you can find more details about it in <a class="el" href="md_doc_22-ProxQP__api.html">ProxQP API</a>).</p>
<table class="manual">
<tr>
<th>examples/cpp/solve_without_api.cpp </th><th>examples/python/solve_without_api.py  </th></tr>
<tr>
<td valign="top"><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="sparse_8hpp.html">proxsuite/proxqp/sparse/sparse.hpp</a>&quot;</span> <span class="comment">// get the sparse backend of ProxQP</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="dense_8hpp.html">proxsuite/proxqp/dense/dense.hpp</a>&quot;</span>   <span class="comment">// get the dense backend of ProxQP</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="random__qp__problems_8hpp.html">proxsuite/proxqp/utils/random_qp_problems.hpp</a>&quot;</span> <span class="comment">// used for generating a random convex qp</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceproxsuite_1_1proxqp.html">proxsuite::proxqp</a>;</div>
<div class="line"><span class="keyword">using </span>T = double;</div>
<div class="line"><span class="keyword">using </span>Mat = <a class="code hl_typedef" href="namespaceproxsuite_1_1proxqp_1_1dense.html#af13d7b939fcad4c391b28d2972e0d919">dense::Mat&lt;T&gt;</a>;</div>
<div class="line"><span class="keyword">using </span>Vec = <a class="code hl_typedef" href="namespaceproxsuite_1_1proxqp_1_1dense.html#accf7cf9dc4fa03c0260aebf96f193875">dense::Vec&lt;T&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main()</div>
<div class="line">{</div>
<div class="line">  isize n = 10;</div>
<div class="line">  isize n_eq(n / 4);</div>
<div class="line">  isize n_in(n / 4);</div>
<div class="line">  T p = 0.35;            <span class="comment">// level of sparsity</span></div>
<div class="line">  T conditioning = 10.0; <span class="comment">// conditioning level for H</span></div>
<div class="line">  <span class="keyword">auto</span> H = utils::rand::sparse_positive_definite_rand(</div>
<div class="line">    n, conditioning, p); <span class="comment">// upper triangular matrix</span></div>
<div class="line">  Mat H_dense = Mat(H);</div>
<div class="line">  H_dense.template triangularView&lt;Eigen::Lower&gt;() = H_dense.transpose();</div>
<div class="line">  Vec g = utils::rand::vector_rand&lt;T&gt;(n);</div>
<div class="line">  <span class="keyword">auto</span> A = utils::rand::sparse_matrix_rand&lt;T&gt;(n_eq, n, p);</div>
<div class="line">  Mat A_dense = Mat(A);</div>
<div class="line">  <span class="keyword">auto</span> C = utils::rand::sparse_matrix_rand&lt;T&gt;(n_in, n, p);</div>
<div class="line">  Mat C_dense = Mat(C);</div>
<div class="line">  Vec x_sol = utils::rand::vector_rand&lt;T&gt;(n);</div>
<div class="line">  Vec b = A * x_sol;</div>
<div class="line">  Vec l = C * x_sol;</div>
<div class="line">  Vec u = (l.array() + 10).matrix();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Solve the problem using the sparse backend</span></div>
<div class="line">  <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1Results.html">Results&lt;T&gt;</a> results_sparse_solver =</div>
<div class="line">    sparse::solve&lt;T, isize&gt;(H, g, A, b, C, l, u);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal x from sparse solver: &quot;</span> &lt;&lt; results_sparse_solver.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1Results.html#ad05a360234a4dce744c868b6aad72f8f">x</a></div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal y from sparse solver: &quot;</span> &lt;&lt; results_sparse_solver.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1Results.html#ab412e8dbd9325586ca0d8b299a31b21f">y</a></div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal z from sparse solver: &quot;</span> &lt;&lt; results_sparse_solver.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1Results.html#a1be314db5179afe99216d9564ee35ffb">z</a></div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line">  <span class="comment">// Solve the problem using the dense backend</span></div>
<div class="line">  <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1Results.html">Results&lt;T&gt;</a> results_dense_solver =</div>
<div class="line">    dense::solve&lt;T&gt;(H_dense, g, A_dense, b, C_dense, l, u);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// print an optimal solution x,y and z</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal x from dense solver: &quot;</span> &lt;&lt; results_dense_solver.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1Results.html#ad05a360234a4dce744c868b6aad72f8f">x</a></div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal y from dense solver: &quot;</span> &lt;&lt; results_dense_solver.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1Results.html#ab412e8dbd9325586ca0d8b299a31b21f">y</a></div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal z from dense solver: &quot;</span> &lt;&lt; results_dense_solver.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1Results.html#a1be314db5179afe99216d9564ee35ffb">z</a></div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Solve the problem using the dense backend using its feature for handling</span></div>
<div class="line">  <span class="comment">// box constraints</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// some trivial boxes</span></div>
<div class="line">  Vec u_box(n);</div>
<div class="line">  Vec l_box(n);</div>
<div class="line">  u_box.setZero();</div>
<div class="line">  l_box.setZero();</div>
<div class="line">  u_box.array() += 1.E10;</div>
<div class="line">  l_box.array() -= 1.E10;</div>
<div class="line">  <span class="comment">// make sure to specify at least next 9 variables of the solve function after</span></div>
<div class="line">  <span class="comment">// u_box to make sure the overloading work and use the specific feature for</span></div>
<div class="line">  <span class="comment">// handling more efficiently box constraints</span></div>
<div class="line">  <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1Results.html">Results&lt;T&gt;</a> results_dense_solver_box = dense::solve&lt;T&gt;(H_dense,</div>
<div class="line">                                                        g,</div>
<div class="line">                                                        A_dense,</div>
<div class="line">                                                        b,</div>
<div class="line">                                                        C_dense,</div>
<div class="line">                                                        l,</div>
<div class="line">                                                        u,</div>
<div class="line">                                                        l_box,</div>
<div class="line">                                                        u_box,</div>
<div class="line">                                                        <a class="code hl_variable" href="namespaceproxsuite.html#a2031f223e16b21ebc8f804797aa4a635">proxsuite::nullopt</a>,</div>
<div class="line">                                                        <a class="code hl_variable" href="namespaceproxsuite.html#a2031f223e16b21ebc8f804797aa4a635">proxsuite::nullopt</a>,</div>
<div class="line">                                                        <a class="code hl_variable" href="namespaceproxsuite.html#a2031f223e16b21ebc8f804797aa4a635">proxsuite::nullopt</a>,</div>
<div class="line">                                                        <a class="code hl_variable" href="namespaceproxsuite.html#a2031f223e16b21ebc8f804797aa4a635">proxsuite::nullopt</a>,</div>
<div class="line">                                                        <a class="code hl_variable" href="namespaceproxsuite.html#a2031f223e16b21ebc8f804797aa4a635">proxsuite::nullopt</a>,</div>
<div class="line">                                                        <a class="code hl_variable" href="namespaceproxsuite.html#a2031f223e16b21ebc8f804797aa4a635">proxsuite::nullopt</a>,</div>
<div class="line">                                                        <a class="code hl_variable" href="namespaceproxsuite.html#a2031f223e16b21ebc8f804797aa4a635">proxsuite::nullopt</a>,</div>
<div class="line">                                                        <a class="code hl_variable" href="namespaceproxsuite.html#a2031f223e16b21ebc8f804797aa4a635">proxsuite::nullopt</a>,</div>
<div class="line">                                                        <a class="code hl_variable" href="namespaceproxsuite.html#a2031f223e16b21ebc8f804797aa4a635">proxsuite::nullopt</a>);</div>
<div class="line">  <span class="comment">// print an optimal solution x,y and z</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal x from dense solver: &quot;</span> &lt;&lt; results_dense_solver.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1Results.html#ad05a360234a4dce744c868b6aad72f8f">x</a></div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal y from dense solver: &quot;</span> &lt;&lt; results_dense_solver.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1Results.html#ab412e8dbd9325586ca0d8b299a31b21f">y</a></div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal z from dense solver: &quot;</span> &lt;&lt; results_dense_solver.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1Results.html#a1be314db5179afe99216d9564ee35ffb">z</a></div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line">  <span class="comment">// Note that the last n elements of z corresponds to the multipliers</span></div>
<div class="line">  <span class="comment">// associated to the box constraints</span></div>
<div class="line">}</div>
<div class="ttc" id="adense_8hpp_html"><div class="ttname"><a href="dense_8hpp.html">dense.hpp</a></div></div>
<div class="ttc" id="anamespaceproxsuite_1_1proxqp_1_1dense_html_accf7cf9dc4fa03c0260aebf96f193875"><div class="ttname"><a href="namespaceproxsuite_1_1proxqp_1_1dense.html#accf7cf9dc4fa03c0260aebf96f193875">proxsuite::proxqp::dense::Vec</a></div><div class="ttdeci">Eigen::Matrix&lt; T, DYN, 1 &gt; Vec</div><div class="ttdef"><b>Definition</b> <a href="proxqp_2dense_2fwd_8hpp_source.html#l00024">fwd.hpp:24</a></div></div>
<div class="ttc" id="anamespaceproxsuite_1_1proxqp_1_1dense_html_af13d7b939fcad4c391b28d2972e0d919"><div class="ttname"><a href="namespaceproxsuite_1_1proxqp_1_1dense.html#af13d7b939fcad4c391b28d2972e0d919">proxsuite::proxqp::dense::Mat</a></div><div class="ttdeci">Eigen::Matrix&lt; T, DYN, DYN, l &gt; Mat</div><div class="ttdef"><b>Definition</b> <a href="proxqp_2dense_2fwd_8hpp_source.html#l00031">fwd.hpp:31</a></div></div>
<div class="ttc" id="anamespaceproxsuite_1_1proxqp_html"><div class="ttname"><a href="namespaceproxsuite_1_1proxqp.html">proxsuite::proxqp</a></div><div class="ttdef"><b>Definition</b> <a href="backward__data_8hpp_source.html#l00016">backward_data.hpp:16</a></div></div>
<div class="ttc" id="anamespaceproxsuite_html_a2031f223e16b21ebc8f804797aa4a635"><div class="ttname"><a href="namespaceproxsuite.html#a2031f223e16b21ebc8f804797aa4a635">proxsuite::nullopt</a></div><div class="ttdeci">constexpr nullopt_t nullopt</div><div class="ttdef"><b>Definition</b> <a href="optional_8hpp_source.html#l00042">optional.hpp:42</a></div></div>
<div class="ttc" id="arandom__qp__problems_8hpp_html"><div class="ttname"><a href="random__qp__problems_8hpp.html">random_qp_problems.hpp</a></div></div>
<div class="ttc" id="asparse_8hpp_html"><div class="ttname"><a href="sparse_8hpp.html">sparse.hpp</a></div></div>
<div class="ttc" id="astructproxsuite_1_1proxqp_1_1Results_html"><div class="ttname"><a href="structproxsuite_1_1proxqp_1_1Results.html">proxsuite::proxqp::Results</a></div><div class="ttdoc">This class stores all the results of PROXQP solvers with sparse and dense backends.</div><div class="ttdef"><b>Definition</b> <a href="proxqp_2results_8hpp_source.html#l00067">results.hpp:68</a></div></div>
<div class="ttc" id="astructproxsuite_1_1proxqp_1_1Results_html_a1be314db5179afe99216d9564ee35ffb"><div class="ttname"><a href="structproxsuite_1_1proxqp_1_1Results.html#a1be314db5179afe99216d9564ee35ffb">proxsuite::proxqp::Results::z</a></div><div class="ttdeci">sparse::Vec&lt; T &gt; z</div><div class="ttdef"><b>Definition</b> <a href="proxqp_2results_8hpp_source.html#l00074">results.hpp:74</a></div></div>
<div class="ttc" id="astructproxsuite_1_1proxqp_1_1Results_html_ab412e8dbd9325586ca0d8b299a31b21f"><div class="ttname"><a href="structproxsuite_1_1proxqp_1_1Results.html#ab412e8dbd9325586ca0d8b299a31b21f">proxsuite::proxqp::Results::y</a></div><div class="ttdeci">sparse::Vec&lt; T &gt; y</div><div class="ttdef"><b>Definition</b> <a href="proxqp_2results_8hpp_source.html#l00073">results.hpp:73</a></div></div>
<div class="ttc" id="astructproxsuite_1_1proxqp_1_1Results_html_ad05a360234a4dce744c868b6aad72f8f"><div class="ttname"><a href="structproxsuite_1_1proxqp_1_1Results.html#ad05a360234a4dce744c868b6aad72f8f">proxsuite::proxqp::Results::x</a></div><div class="ttdeci">sparse::Vec&lt; T &gt; x</div><div class="ttdef"><b>Definition</b> <a href="proxqp_2results_8hpp_source.html#l00072">results.hpp:72</a></div></div>
</div><!-- fragment -->  </td><td valign="top"><div class="fragment"><div class="line"><span class="keyword">import</span> proxsuite</div>
<div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"><span class="keyword">import</span> scipy.sparse <span class="keyword">as</span> spa</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>generate_mixed_qp(n, seed=1):</div>
<div class="line">    <span class="comment"># A function for generating sparse random convex qps in dense format</span></div>
<div class="line"> </div>
<div class="line">    np.random.seed(seed)</div>
<div class="line">    n_eq = int(n / 4)</div>
<div class="line">    n_in = int(n / 4)</div>
<div class="line">    m = n_eq + n_in</div>
<div class="line"> </div>
<div class="line">    P = spa.random(</div>
<div class="line">        n, n, density=0.075, data_rvs=np.random.randn, format=<span class="stringliteral">&quot;csc&quot;</span></div>
<div class="line">    ).toarray()</div>
<div class="line">    P = (P + P.T) / 2.0</div>
<div class="line"> </div>
<div class="line">    s = max(np.absolute(np.linalg.eigvals(P)))</div>
<div class="line">    P += (abs(s) + 1e-02) * spa.eye(n)</div>
<div class="line">    P = spa.coo_matrix(P)</div>
<div class="line">    q = np.random.randn(n)</div>
<div class="line">    A = spa.random(m, n, density=0.15, data_rvs=np.random.randn, format=<span class="stringliteral">&quot;csc&quot;</span>)</div>
<div class="line">    v = np.random.randn(n)  <span class="comment"># Fictitious solution</span></div>
<div class="line">    delta = np.random.rand(m)  <span class="comment"># To get inequality</span></div>
<div class="line">    u = A @ v</div>
<div class="line">    l = -1.0e20 * np.ones(m)</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> P, q, A[:n_eq, :], u[:n_eq], A[n_in:, :], u[n_in:], l[n_in:]</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment"># load a qp object using qp problem dimensions</span></div>
<div class="line">n = 10</div>
<div class="line">n_eq = 2</div>
<div class="line">n_in = 2</div>
<div class="line">H, g, A, b, C, u, l = generate_mixed_qp(n)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># solve the problem using the sparse backend</span></div>
<div class="line">results = <a class="code hl_function" href="namespaceproxsuite_1_1proxqp_1_1sparse.html#a79803f770b3b7be596e5545fa8e5e63f">proxsuite.proxqp.sparse.solve</a>(H, g, A, b, C, l, u)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># solve the problem using the dense backend</span></div>
<div class="line"> </div>
<div class="line">results2 = <a class="code hl_function" href="namespaceproxsuite_1_1proxqp_1_1dense.html#a871a143ee2375751f1b17eabb1ef7df5">proxsuite.proxqp.dense.solve</a>(</div>
<div class="line">    H.toarray(), g, A.toarray(), b, C.toarray(), l, u</div>
<div class="line">)</div>
<div class="line"><span class="comment"># Note finally, that the matrices are in sparse format, when using the dense backend you</span></div>
<div class="line"><span class="comment"># should convert them in dense format</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># print an optimal solution</span></div>
<div class="line">print(<span class="stringliteral">&quot;optimal x: {}&quot;</span>.format(results.x))</div>
<div class="line">print(<span class="stringliteral">&quot;optimal y: {}&quot;</span>.format(results.y))</div>
<div class="line">print(<span class="stringliteral">&quot;optimal z: {}&quot;</span>.format(results.z))</div>
<div class="line"> </div>
<div class="line"><span class="comment"># solve the problem using the dense backend using its feature for handling box constraints</span></div>
<div class="line"> </div>
<div class="line">l_box = -np.ones(n) * 1.0e10</div>
<div class="line">u_box = np.ones(n) * 1.0e10</div>
<div class="line"> </div>
<div class="line"><span class="comment"># make sure to specify l_box=l_box, u_box=u_box in order to make work the</span></div>
<div class="line"><span class="comment"># overloading</span></div>
<div class="line">results_dense_solver_box = <a class="code hl_function" href="namespaceproxsuite_1_1proxqp_1_1dense.html#a871a143ee2375751f1b17eabb1ef7df5">proxsuite.proxqp.dense.solve</a>(</div>
<div class="line">    H.toarray(), g, A.toarray(), b, C.toarray(), l, u, l_box=l_box, u_box=u_box</div>
<div class="line">)</div>
<div class="line"><span class="comment"># print an optimal solution</span></div>
<div class="line">print(<span class="stringliteral">&quot;optimal x: {}&quot;</span>.format(results_dense_solver_box.x))</div>
<div class="line">print(<span class="stringliteral">&quot;optimal y: {}&quot;</span>.format(results_dense_solver_box.y))</div>
<div class="line">print(<span class="stringliteral">&quot;optimal z: {}&quot;</span>.format(results_dense_solver_box.z))</div>
<div class="line"><span class="comment"># Note that the last n elements of z corresponds to the multipliers associated to the box</span></div>
<div class="line"><span class="comment"># constraints</span></div>
<div class="ttc" id="anamespaceproxsuite_1_1proxqp_1_1dense_html_a871a143ee2375751f1b17eabb1ef7df5"><div class="ttname"><a href="namespaceproxsuite_1_1proxqp_1_1dense.html#a871a143ee2375751f1b17eabb1ef7df5">proxsuite::proxqp::dense::solve</a></div><div class="ttdeci">proxqp::Results&lt; T &gt; solve(optional&lt; MatRef&lt; T &gt; &gt; H, optional&lt; VecRef&lt; T &gt; &gt; g, optional&lt; MatRef&lt; T &gt; &gt; A, optional&lt; VecRef&lt; T &gt; &gt; b, optional&lt; MatRef&lt; T &gt; &gt; C, optional&lt; VecRef&lt; T &gt; &gt; l, optional&lt; VecRef&lt; T &gt; &gt; u, optional&lt; VecRef&lt; T &gt; &gt; x=nullopt, optional&lt; VecRef&lt; T &gt; &gt; y=nullopt, optional&lt; VecRef&lt; T &gt; &gt; z=nullopt, optional&lt; T &gt; eps_abs=nullopt, optional&lt; T &gt; eps_rel=nullopt, optional&lt; T &gt; rho=nullopt, optional&lt; T &gt; mu_eq=nullopt, optional&lt; T &gt; mu_in=nullopt, optional&lt; bool &gt; verbose=nullopt, bool compute_preconditioner=true, bool compute_timings=false, optional&lt; isize &gt; max_iter=nullopt, proxsuite::proxqp::InitialGuessStatus initial_guess=proxsuite::proxqp::InitialGuessStatus::EQUALITY_CONSTRAINED_INITIAL_GUESS, bool check_duality_gap=false, optional&lt; T &gt; eps_duality_gap_abs=nullopt, optional&lt; T &gt; eps_duality_gap_rel=nullopt, bool primal_infeasibility_solving=false, optional&lt; T &gt; manual_minimal_H_eigenvalue=nullopt)</div><div class="ttdef"><b>Definition</b> <a href="proxqp_2dense_2wrapper_8hpp_source.html#l01002">wrapper.hpp:1002</a></div></div>
<div class="ttc" id="anamespaceproxsuite_1_1proxqp_1_1sparse_html_a79803f770b3b7be596e5545fa8e5e63f"><div class="ttname"><a href="namespaceproxsuite_1_1proxqp_1_1sparse.html#a79803f770b3b7be596e5545fa8e5e63f">proxsuite::proxqp::sparse::solve</a></div><div class="ttdeci">proxqp::Results&lt; T &gt; solve(optional&lt; SparseMat&lt; T, I &gt; &gt; H, optional&lt; VecRef&lt; T &gt; &gt; g, optional&lt; SparseMat&lt; T, I &gt; &gt; A, optional&lt; VecRef&lt; T &gt; &gt; b, optional&lt; SparseMat&lt; T, I &gt; &gt; C, optional&lt; VecRef&lt; T &gt; &gt; l, optional&lt; VecRef&lt; T &gt; &gt; u, optional&lt; VecRef&lt; T &gt; &gt; x=nullopt, optional&lt; VecRef&lt; T &gt; &gt; y=nullopt, optional&lt; VecRef&lt; T &gt; &gt; z=nullopt, optional&lt; T &gt; eps_abs=nullopt, optional&lt; T &gt; eps_rel=nullopt, optional&lt; T &gt; rho=nullopt, optional&lt; T &gt; mu_eq=nullopt, optional&lt; T &gt; mu_in=nullopt, optional&lt; bool &gt; verbose=nullopt, bool compute_preconditioner=true, bool compute_timings=false, optional&lt; isize &gt; max_iter=nullopt, proxsuite::proxqp::InitialGuessStatus initial_guess=proxsuite::proxqp::InitialGuessStatus::EQUALITY_CONSTRAINED_INITIAL_GUESS, proxsuite::proxqp::SparseBackend sparse_backend=proxsuite::proxqp::SparseBackend::Automatic, bool check_duality_gap=false, optional&lt; T &gt; eps_duality_gap_abs=nullopt, optional&lt; T &gt; eps_duality_gap_rel=nullopt, bool primal_infeasibility_solving=false, optional&lt; T &gt; manual_minimal_H_eigenvalue=nullopt)</div><div class="ttdef"><b>Definition</b> <a href="proxqp_2sparse_2wrapper_8hpp_source.html#l00707">wrapper.hpp:707</a></div></div>
</div><!-- fragment -->   </td></tr>
</table>
<p>The results of the solve call are available in the result object, which structure is described in <a class="el" href="md_doc_22-ProxQP__api.html">ProxQP API with examples</a> section (at "The results subclass" subsection).</p>
<p>Different options are available for the solve function. In the table below you have the list of the different parameters that can be specified in the solve function (without the model of the problem to solve). We precise from left to right their name, their default value, and a short description of it.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Option   </th><th class="markdownTableHeadNone">Default value   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">x   </td><td class="markdownTableBodyNone">Value of the EQUALITY_CONSTRAINED_INITIAL_GUESS   </td><td class="markdownTableBodyNone">Warm start value for the primal variable.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">y   </td><td class="markdownTableBodyNone">Value of the EQUALITY_CONSTRAINED_INITIAL_GUESS   </td><td class="markdownTableBodyNone">Warm start value for the dual Lagrange multiplier for equality constraints.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">z   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">Warm start value for the dual Lagrange multiplier for inequality constraints.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">eps_abs   </td><td class="markdownTableBodyNone">1.E-5   </td><td class="markdownTableBodyNone">Asbolute stopping criterion of the solver.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">eps_rel   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">Relative stopping criterion of the solver.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">check_duality_gap   </td><td class="markdownTableBodyNone">False   </td><td class="markdownTableBodyNone">If set to true, include the duality gap in absolute and relative stopping criteria.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">eps_duality_gap_abs   </td><td class="markdownTableBodyNone">1.E-4   </td><td class="markdownTableBodyNone">Asbolute duality-gap stopping criterion of the solver.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">eps_duality_gap_rel   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">Relative duality-gap stopping criterion of the solver.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">mu_eq   </td><td class="markdownTableBodyNone">1.E-3   </td><td class="markdownTableBodyNone">Proximal step size wrt equality constraints multiplier.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">mu_in   </td><td class="markdownTableBodyNone">1.E-1   </td><td class="markdownTableBodyNone">Proximal step size wrt inequality constraints multiplier.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">rho   </td><td class="markdownTableBodyNone">1.E-6   </td><td class="markdownTableBodyNone">Proximal step size wrt primal variable.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">VERBOSE   </td><td class="markdownTableBodyNone">False   </td><td class="markdownTableBodyNone">If set to true, the solver prints information at each loop.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">compute_preconditioner   </td><td class="markdownTableBodyNone">True   </td><td class="markdownTableBodyNone">If set to true, the preconditioner will be derived.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">compute_timings   </td><td class="markdownTableBodyNone">False   </td><td class="markdownTableBodyNone">If set to true, timings will be computed by the solver (setup time, solving time, and run time = setup time + solving time).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">max_iter   </td><td class="markdownTableBodyNone">10.000   </td><td class="markdownTableBodyNone">Maximal number of authorized outer iterations.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">initial_guess   </td><td class="markdownTableBodyNone">EQUALITY_CONSTRAINED_INITIAL_GUESS   </td><td class="markdownTableBodyNone">Sets the initial guess option for initilizing x, y and z.   </td></tr>
</table>
<p>All other settings are set to their default values detailed in <a class="el" href="md_doc_22-ProxQP__api.html">ProxQP API with examples</a> differents subsections of "The settings subclass" section.</p>
<p>Note that contrary to ProxQP API, the default value of the initial guess is the "EQUALITY_CONSTRAINED_INITIAL_GUESS" option. Indeed, there is no meaning in using the "WARM_START_WITH_PREVIOUS_RESULT" option as after the solve call, it is not possible to warm start any Qp object with previous results. Hence, the only meaningful initial guess options are:</p><ul>
<li>EQUALITY_CONSTRAINED_INITIAL_GUESS,</li>
<li>NO_INITIAL_GUESS,</li>
<li>or a WARM_START explicitly provided by the user.</li>
</ul>
<p>For the latter case, It is not necessary to specify the WARM_START initial guess in the solve function. It is sufficient to just add the warm start x, y and z in the solve function, and the solver will automatically make the setting change internally.</p>
<p>Finally, note that in C++, if you want to change one option, the order described above in the table matter. Any intermediary option not changed must be let to the std::nullopt value. In Python, you can just specify the name of the option you want to change in any order. We give an example below.</p>
<table class="manual">
<tr>
<th>examples/cpp/solve_without_api_and_option.cpp </th><th>examples/python/solve_without_api_and_option.py  </th></tr>
<tr>
<td valign="top"><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse_8hpp.html">proxsuite/proxqp/sparse/sparse.hpp</a>&gt;</span> <span class="comment">// get the sparse backend of ProxQP</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dense_8hpp.html">proxsuite/proxqp/dense/dense.hpp</a>&gt;</span>   <span class="comment">// get the dense backend of ProxQP</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="random__qp__problems_8hpp.html">proxsuite/proxqp/utils/random_qp_problems.hpp</a>&gt;</span> <span class="comment">// used for generating a random convex qp</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceproxsuite.html">proxsuite</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceproxsuite_1_1proxqp.html">proxsuite::proxqp</a>;</div>
<div class="line"><span class="keyword">using </span>T = double;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main()</div>
<div class="line">{</div>
<div class="line">  isize n = 10;</div>
<div class="line">  isize n_eq(n / 4);</div>
<div class="line">  isize n_in(n / 4);</div>
<div class="line">  T sparsity_factor(0.15);</div>
<div class="line">  T strong_convexity_factor(1.e-2);</div>
<div class="line">  <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html">dense::Model&lt;T&gt;</a> qp_random = utils::dense_strongly_convex_qp(</div>
<div class="line">    n, n_eq, n_in, sparsity_factor, strong_convexity_factor);</div>
<div class="line">  <span class="comment">// Solve the problem using the dense backend</span></div>
<div class="line">  <span class="comment">// and suppose you want to change the accuracy to 1.E-9 and rho initial value</span></div>
<div class="line">  <span class="comment">// to 1.E-7</span></div>
<div class="line">  <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1Results.html">proxsuite::proxqp::Results&lt;T&gt;</a> results =</div>
<div class="line">    proxsuite::proxqp::dense::solve&lt;T&gt;(qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a420a3bc7af86f6eaf6584f3f6b163e39">H</a>,</div>
<div class="line">                                       qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#aab44afb08fed7665a9a1b6b76123bc2e">g</a>,</div>
<div class="line">                                       qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a2faa69ae13a95d134f8f55e50935486b">A</a>,</div>
<div class="line">                                       qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a35143abc2bf2a3dc4d4d0030376f00d7">b</a>,</div>
<div class="line">                                       qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#ab9585ea151d2a15be6a672b2204f67a9">C</a>,</div>
<div class="line">                                       qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a1e83a4aff28b7e6f81ecb962afaa6166">l</a>,</div>
<div class="line">                                       qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#ab44246d2c5fd3b5bf19e1cfd6e556456">u</a>,</div>
<div class="line">                                       nullopt,</div>
<div class="line">                                       nullopt,</div>
<div class="line">                                       nullopt,</div>
<div class="line">                                       T(1.E-9),</div>
<div class="line">                                       nullopt,</div>
<div class="line">                                       nullopt,</div>
<div class="line">                                       nullopt,</div>
<div class="line">                                       T(1.E-7));</div>
<div class="line">  <span class="comment">// print an optimal solution x,y and z</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal x: &quot;</span> &lt;&lt; results.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1Results.html#ad05a360234a4dce744c868b6aad72f8f">x</a> &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal y: &quot;</span> &lt;&lt; results.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1Results.html#ab412e8dbd9325586ca0d8b299a31b21f">y</a> &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal z: &quot;</span> &lt;&lt; results.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1Results.html#a1be314db5179afe99216d9564ee35ffb">z</a> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceproxsuite_html"><div class="ttname"><a href="namespaceproxsuite.html">proxsuite</a></div><div class="ttdef"><b>Definition</b> <a href="common_8hpp_source.html#l00014">common.hpp:14</a></div></div>
<div class="ttc" id="astructproxsuite_1_1proxqp_1_1dense_1_1Model_html"><div class="ttname"><a href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html">proxsuite::proxqp::dense::Model</a></div><div class="ttdoc">This class stores the model of the QP problem.</div><div class="ttdef"><b>Definition</b> <a href="proxqp_2dense_2model_8hpp_source.html#l00023">model.hpp:24</a></div></div>
<div class="ttc" id="astructproxsuite_1_1proxqp_1_1dense_1_1Model_html_a1e83a4aff28b7e6f81ecb962afaa6166"><div class="ttname"><a href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a1e83a4aff28b7e6f81ecb962afaa6166">proxsuite::proxqp::dense::Model::l</a></div><div class="ttdeci">Vec&lt; T &gt; l</div><div class="ttdef"><b>Definition</b> <a href="proxqp_2dense_2model_8hpp_source.html#l00033">model.hpp:33</a></div></div>
<div class="ttc" id="astructproxsuite_1_1proxqp_1_1dense_1_1Model_html_a2faa69ae13a95d134f8f55e50935486b"><div class="ttname"><a href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a2faa69ae13a95d134f8f55e50935486b">proxsuite::proxqp::dense::Model::A</a></div><div class="ttdeci">Mat&lt; T &gt; A</div><div class="ttdef"><b>Definition</b> <a href="proxqp_2dense_2model_8hpp_source.html#l00029">model.hpp:29</a></div></div>
<div class="ttc" id="astructproxsuite_1_1proxqp_1_1dense_1_1Model_html_a35143abc2bf2a3dc4d4d0030376f00d7"><div class="ttname"><a href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a35143abc2bf2a3dc4d4d0030376f00d7">proxsuite::proxqp::dense::Model::b</a></div><div class="ttdeci">Vec&lt; T &gt; b</div><div class="ttdef"><b>Definition</b> <a href="proxqp_2dense_2model_8hpp_source.html#l00031">model.hpp:31</a></div></div>
<div class="ttc" id="astructproxsuite_1_1proxqp_1_1dense_1_1Model_html_a420a3bc7af86f6eaf6584f3f6b163e39"><div class="ttname"><a href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a420a3bc7af86f6eaf6584f3f6b163e39">proxsuite::proxqp::dense::Model::H</a></div><div class="ttdeci">Mat&lt; T &gt; H</div><div class="ttdef"><b>Definition</b> <a href="proxqp_2dense_2model_8hpp_source.html#l00027">model.hpp:27</a></div></div>
<div class="ttc" id="astructproxsuite_1_1proxqp_1_1dense_1_1Model_html_aab44afb08fed7665a9a1b6b76123bc2e"><div class="ttname"><a href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#aab44afb08fed7665a9a1b6b76123bc2e">proxsuite::proxqp::dense::Model::g</a></div><div class="ttdeci">Vec&lt; T &gt; g</div><div class="ttdef"><b>Definition</b> <a href="proxqp_2dense_2model_8hpp_source.html#l00028">model.hpp:28</a></div></div>
<div class="ttc" id="astructproxsuite_1_1proxqp_1_1dense_1_1Model_html_ab44246d2c5fd3b5bf19e1cfd6e556456"><div class="ttname"><a href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#ab44246d2c5fd3b5bf19e1cfd6e556456">proxsuite::proxqp::dense::Model::u</a></div><div class="ttdeci">Vec&lt; T &gt; u</div><div class="ttdef"><b>Definition</b> <a href="proxqp_2dense_2model_8hpp_source.html#l00032">model.hpp:32</a></div></div>
<div class="ttc" id="astructproxsuite_1_1proxqp_1_1dense_1_1Model_html_ab9585ea151d2a15be6a672b2204f67a9"><div class="ttname"><a href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#ab9585ea151d2a15be6a672b2204f67a9">proxsuite::proxqp::dense::Model::C</a></div><div class="ttdeci">Mat&lt; T &gt; C</div><div class="ttdef"><b>Definition</b> <a href="proxqp_2dense_2model_8hpp_source.html#l00030">model.hpp:30</a></div></div>
</div><!-- fragment -->  </td><td valign="top"><div class="fragment"><div class="line"><span class="keyword">import</span> proxsuite</div>
<div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"><span class="keyword">import</span> scipy.sparse <span class="keyword">as</span> spa</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>generate_mixed_qp(n, seed=1):</div>
<div class="line">    <span class="comment"># A function for generating sparse random convex qps in dense format</span></div>
<div class="line"> </div>
<div class="line">    np.random.seed(seed)</div>
<div class="line">    n_eq = int(n / 4)</div>
<div class="line">    n_in = int(n / 4)</div>
<div class="line">    m = n_eq + n_in</div>
<div class="line"> </div>
<div class="line">    P = spa.random(</div>
<div class="line">        n, n, density=0.075, data_rvs=np.random.randn, format=<span class="stringliteral">&quot;csc&quot;</span></div>
<div class="line">    ).toarray()</div>
<div class="line">    P = (P + P.T) / 2.0</div>
<div class="line"> </div>
<div class="line">    s = max(np.absolute(np.linalg.eigvals(P)))</div>
<div class="line">    P += (abs(s) + 1e-02) * spa.eye(n)</div>
<div class="line">    P = spa.coo_matrix(P)</div>
<div class="line">    q = np.random.randn(n)</div>
<div class="line">    A = spa.random(m, n, density=0.15, data_rvs=np.random.randn, format=<span class="stringliteral">&quot;csc&quot;</span>).toarray()</div>
<div class="line">    v = np.random.randn(n)  <span class="comment"># Fictitious solution</span></div>
<div class="line">    delta = np.random.rand(m)  <span class="comment"># To get inequality</span></div>
<div class="line">    u = A @ v</div>
<div class="line">    l = -1.0e20 * np.ones(m)</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> P.toarray(), q, A[:n_eq, :], u[:n_eq], A[n_in:, :], u[n_in:], l[n_in:]</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment"># load a qp object using qp problem dimensions</span></div>
<div class="line">n = 10</div>
<div class="line">n_eq = 2</div>
<div class="line">n_in = 2</div>
<div class="line">H, g, A, b, C, u, l = generate_mixed_qp(n)</div>
<div class="line"><span class="comment"># solve the problem using the sparse backend</span></div>
<div class="line"><span class="comment"># and suppose you want to change the accuracy to 1.E-9 and rho initial value to 1.E-7</span></div>
<div class="line">results = <a class="code hl_function" href="namespaceproxsuite_1_1proxqp_1_1dense.html#a871a143ee2375751f1b17eabb1ef7df5">proxsuite.proxqp.dense.solve</a>(</div>
<div class="line">    H=H, g=g, A=A, b=b, C=C, l=l, u=u, rho=1.0e-7, eps_abs=1.0e-9</div>
<div class="line">)</div>
<div class="line"><span class="comment"># Note that in python the order does not matter for rho and eps_abs</span></div>
<div class="line"><span class="comment"># print an optimal solution</span></div>
<div class="line">print(<span class="stringliteral">&quot;optimal x: {}&quot;</span>.format(results.x))</div>
<div class="line">print(<span class="stringliteral">&quot;optimal y: {}&quot;</span>.format(results.y))</div>
<div class="line">print(<span class="stringliteral">&quot;optimal z: {}&quot;</span>.format(results.z))</div>
</div><!-- fragment -->   </td></tr>
</table>
<p>Note that if some elements of your QP model are not defined (for example a QP without linear cost or inequality constraints), you can either pass a None argument, or a matrix with zero shape for specifying it. We provide an example below in cpp and python (for the dense case, it is similar with sparse backend).</p>
<table class="manual">
<tr>
<th>examples/cpp/initializing_with_none_without_api.cpp </th><th>examples/python/initializing_with_none_without_api.py  </th></tr>
<tr>
<td valign="top"><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="dense_8hpp.html">proxsuite/proxqp/dense/dense.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="random__qp__problems_8hpp.html">proxsuite/proxqp/utils/random_qp_problems.hpp</a>&gt;</span> <span class="comment">// used for generating a random convex qp</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceproxsuite_1_1proxqp.html">proxsuite::proxqp</a>;</div>
<div class="line"><span class="keyword">using </span>T = double;</div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main()</div>
<div class="line">{</div>
<div class="line">  dense::isize dim = 10;</div>
<div class="line">  dense::isize n_eq(0);</div>
<div class="line">  dense::isize n_in(0);</div>
<div class="line">  T strong_convexity_factor(0.1);</div>
<div class="line">  T sparsity_factor(0.15);</div>
<div class="line">  <span class="comment">// we generate a qp, so the function used from helpers.hpp is</span></div>
<div class="line">  <span class="comment">// in proxqp namespace. The qp is in dense eigen format and</span></div>
<div class="line">  <span class="comment">// you can control its sparsity ratio and strong convexity factor.</span></div>
<div class="line">  <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html">dense::Model&lt;T&gt;</a> qp_random = utils::dense_strongly_convex_qp(</div>
<div class="line">    dim, n_eq, n_in, sparsity_factor, strong_convexity_factor);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1Results.html">Results&lt;T&gt;</a> results =</div>
<div class="line">    dense::solve&lt;T&gt;(qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a420a3bc7af86f6eaf6584f3f6b163e39">H</a>,</div>
<div class="line">                    qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#aab44afb08fed7665a9a1b6b76123bc2e">g</a>,</div>
<div class="line">                    qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a2faa69ae13a95d134f8f55e50935486b">A</a>,</div>
<div class="line">                    qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a35143abc2bf2a3dc4d4d0030376f00d7">b</a>,</div>
<div class="line">                    qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#ab9585ea151d2a15be6a672b2204f67a9">C</a>,</div>
<div class="line">                    qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#a1e83a4aff28b7e6f81ecb962afaa6166">l</a>,</div>
<div class="line">                    qp_random.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1dense_1_1Model.html#ab44246d2c5fd3b5bf19e1cfd6e556456">u</a>); <span class="comment">// initialization with zero shape matrices</span></div>
<div class="line">  <span class="comment">// it is equivalent to do dense::solve&lt;T&gt;(qp_random.H, qp_random.g,</span></div>
<div class="line">  <span class="comment">// nullopt,nullopt,nullopt,nullopt,nullopt);</span></div>
<div class="line">  <span class="comment">//  print an optimal solution x,y and z</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal x: &quot;</span> &lt;&lt; results.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1Results.html#ad05a360234a4dce744c868b6aad72f8f">x</a> &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal y: &quot;</span> &lt;&lt; results.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1Results.html#ab412e8dbd9325586ca0d8b299a31b21f">y</a> &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;optimal z: &quot;</span> &lt;&lt; results.<a class="code hl_variable" href="structproxsuite_1_1proxqp_1_1Results.html#a1be314db5179afe99216d9564ee35ffb">z</a> &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment -->  </td><td valign="top"><div class="fragment"><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"><span class="keyword">import</span> proxsuite</div>
<div class="line"> </div>
<div class="line">H = np.array([[65.0, -22.0, -16.0], [-22.0, 14.0, 7.0], [-16.0, 7.0, 5.0]])</div>
<div class="line">g = np.array([-13.0, 15.0, 7.0])</div>
<div class="line">A = <span class="keywordtype">None</span></div>
<div class="line">b = <span class="keywordtype">None</span></div>
<div class="line">C = <span class="keywordtype">None</span></div>
<div class="line">u = <span class="keywordtype">None</span></div>
<div class="line">l = <span class="keywordtype">None</span></div>
<div class="line"> </div>
<div class="line">results = <a class="code hl_function" href="namespaceproxsuite_1_1proxqp_1_1dense.html#a871a143ee2375751f1b17eabb1ef7df5">proxsuite.proxqp.dense.solve</a>(</div>
<div class="line">    H, g, A, b, C, l, u</div>
<div class="line">)  <span class="comment"># it is equivalent to do as well proxsuite.proxqp.dense.solve(H, g)</span></div>
<div class="line">print(<span class="stringliteral">&quot;optimal x: {}&quot;</span>.format(results.x))</div>
</div><!-- fragment -->   </td></tr>
</table>
<p>Finally, note that you can also you ProxQP for solving QP with non convex quadratic. For doing so, you just need to provide to the solve function an estimate of the smallest eigenvalue of the quadratic cost H. The solver environment provides an independent function for estimating the minimal eigenvalue of a dense or sparse symmetric matrix. It is named "estimate_minimal_eigen_value_of_symmetric_matrix". You can find more details in <a class="el" href="md_doc_22-ProxQP__api.html">ProxQP API with examples</a> about the different other settings that can be used for setting other related parameters (e.g., for using a Power Iteration algorithm). </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.10.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
